{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar queue_1 = require(\"../utils/queue\");\n\nvar RawCalldata =\n/** @class */\nfunction () {\n  function RawCalldata(value, hasSelector) {\n    if (hasSelector === void 0) {\n      hasSelector = true;\n    } // Sanity check\n\n\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    } // Construct initial values\n\n\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n\n    this._offset = RawCalldata._INITIAL_OFFSET; // If there's a selector then slice it\n\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n\n  RawCalldata.prototype.popBytes = function (lengthInBytes) {\n    var popBegin = this._offset;\n    var popEnd = popBegin + lengthInBytes;\n\n    if (popEnd > this._value.byteLength) {\n      throw new Error(\"Tried to decode beyond the end of calldata\");\n    }\n\n    var value = this._value.slice(popBegin, popEnd);\n\n    this.setOffset(popEnd);\n    return value;\n  };\n\n  RawCalldata.prototype.popWord = function () {\n    var wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  };\n\n  RawCalldata.prototype.popWords = function (length) {\n    var wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  };\n\n  RawCalldata.prototype.readBytes = function (from, to) {\n    var value = this._value.slice(from, to);\n\n    return value;\n  };\n\n  RawCalldata.prototype.setOffset = function (offsetInBytes) {\n    this._offset = offsetInBytes;\n  };\n\n  RawCalldata.prototype.startScope = function () {\n    this._scopes.pushFront(this._offset);\n  };\n\n  RawCalldata.prototype.endScope = function () {\n    this._scopes.popFront();\n  };\n\n  RawCalldata.prototype.getOffset = function () {\n    return this._offset;\n  };\n\n  RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n    var scopeOffset = this._scopes.peekFront();\n\n    if (scopeOffset === undefined) {\n      throw new Error(\"Tried to access undefined scope.\");\n    }\n\n    var absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  };\n\n  RawCalldata.prototype.getSelector = function () {\n    return this._selector;\n  };\n\n  RawCalldata.prototype.getSizeInBytes = function () {\n    var sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  };\n\n  RawCalldata._INITIAL_OFFSET = 0;\n  return RawCalldata;\n}();\n\nexports.RawCalldata = RawCalldata;","map":{"version":3,"mappings":"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","names":["value","hasSelector","_","startsWith","Error","_value","ethUtil","toBuffer","_selector","_scopes","queue_1","pushBack","RawCalldata","_INITIAL_OFFSET","_offset","selectorBuf","slice","constants_1","HEX_SELECTOR_LENGTH_IN_BYTES","bufferToHex","lengthInBytes","popBegin","popEnd","byteLength","setOffset","wordInBytes","popBytes","length","from","to","offsetInBytes","pushFront","popFront","relativeOffset","scopeOffset","peekFront","undefined","absoluteOffset","sizeInBytes","exports"],"sources":["../../../../src/abi_encoder/calldata/raw_calldata.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}