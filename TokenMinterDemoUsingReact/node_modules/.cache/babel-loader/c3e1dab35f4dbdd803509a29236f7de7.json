{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"@0x/assert\");\n\nvar json_schemas_1 = require(\"@0x/json-schemas\");\n\nvar utils_1 = require(\"@0x/utils\");\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar marshaller_1 = require(\"./marshaller\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_2 = require(\"./utils\");\n\nvar BASE_TEN = 10; // These are unique identifiers contained in the response of the\n// web3_clientVersion call.\n\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\n\nvar Web3Wrapper =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n    if (callAndTxnDefaults === void 0) {\n      callAndTxnDefaults = {};\n    }\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n\n\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n\n\n  Web3Wrapper.isAddress = function (address) {\n    return utils_1.addressUtils.isAddress(address);\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  Web3Wrapper.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n\n\n  Web3Wrapper.toWei = function (ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    var ETH_DECIMALS = 18;\n    var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  };\n\n  Web3Wrapper._assertBlockParam = function (blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  };\n\n  Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n      }\n    }\n  };\n\n  Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  };\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getContractDefaults = function () {\n    return this._callAndTxnDefaults;\n  };\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n\n\n  Web3Wrapper.prototype.getProvider = function () {\n    return this._supportedProvider;\n  };\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n\n\n  Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n    var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  };\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n\n\n  Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            return [4\n            /*yield*/\n            , this.getAvailableAddressesAsync()];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddress = senderAddress.toLowerCase();\n            return [2\n            /*return*/\n            , _.includes(addresses, normalizedAddress)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n\n\n  Web3Wrapper.prototype.getNodeVersionAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nodeVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'web3_clientVersion'\n            })];\n\n          case 1:\n            nodeVersion = _a.sent();\n            return [2\n            /*return*/\n            , nodeVersion];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n\n\n  Web3Wrapper.prototype.getNetworkIdAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var networkIdStr, networkId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'net_version'\n            })];\n\n          case 1:\n            networkIdStr = _a.sent();\n            networkId = _.parseInt(networkIdStr);\n            return [2\n            /*return*/\n            , networkId];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n\n\n  Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceiptRpc, transactionReceipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionReceipt',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionReceiptRpc = _a.sent(); // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return [2\n              /*return*/\n              , transactionReceipt];\n            } else {\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n\n\n  Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionRpc, transaction;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionByHash',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionRpc = _a.sent();\n            transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return [2\n            /*return*/\n            , transaction];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n\n\n  Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedOwner, balanceInWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('owner', owner);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getBalance',\n              params: [encodedOwner, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            balanceInWei = _a.sent(); // Rewrap in a new BigNumber\n\n            return [2\n            /*return*/\n            , new utils_1.BigNumber(balanceInWei)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n\n\n  Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var code, isCodeEmpty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            return [4\n            /*yield*/\n            , this.getContractCodeAsync(address)];\n\n          case 1:\n            code = _a.sent();\n            isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return [2\n            /*return*/\n            , !isCodeEmpty];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n\n\n  Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedAddress, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getCode',\n              params: [encodedAddress, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            code = _a.sent();\n            return [2\n            /*return*/\n            , code];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n\n\n  Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trace;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_traceTransaction',\n              params: [txHash, traceParams]\n            })];\n\n          case 1:\n            trace = _a.sent();\n            return [2\n            /*return*/\n            , trace];\n        }\n      });\n    });\n  };\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n\n\n  Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sign',\n              params: [address, message]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n\n\n  Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_signTypedData',\n              params: [address, typedData]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n\n\n  Web3Wrapper.prototype.getBlockNumberAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex, blockNumber;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_blockNumber',\n              params: []\n            })];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return [2\n            /*return*/\n            , blockNumber];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = false;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n              blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n\n            return [2\n            /*return*/\n            , blockWithoutTransactionDataIfExists];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n\n\n  Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = blockParam;\n\n            if (_.isNumber(blockParam)) {\n              encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = true;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithTransactionDataWithHexValues = _a.sent();\n            blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return [2\n            /*return*/\n            , blockWithoutTransactionData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n\n\n  Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            return [4\n            /*yield*/\n            , this.getBlockIfExistsAsync(blockParam)];\n\n          case 1:\n            blockIfExists = _a.sent();\n\n            if (blockIfExists === undefined) {\n              throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n            }\n\n            return [2\n            /*return*/\n            , blockIfExists.timestamp];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n\n\n  Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_accounts',\n              params: []\n            })];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddresses = _.map(addresses, function (address) {\n              return address.toLowerCase();\n            });\n            return [2\n            /*return*/\n            , normalizedAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n\n\n  Web3Wrapper.prototype.takeSnapshotAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshotId, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Number;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_snapshot',\n              params: []\n            })];\n\n          case 1:\n            snapshotId = _a.apply(void 0, [_b.sent()]);\n            return [2\n            /*return*/\n            , snapshotId];\n        }\n      });\n    });\n  };\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n\n\n  Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var didRevert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_revert',\n              params: [snapshotId]\n            })];\n\n          case 1:\n            didRevert = _a.sent();\n            return [2\n            /*return*/\n            , didRevert];\n        }\n      });\n    });\n  };\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n\n\n  Web3Wrapper.prototype.mineBlockAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_mine',\n              params: []\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n\n\n  Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              })];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              })];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n\n\n  Web3Wrapper.prototype.getLogsAsync = function (filter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            }\n\n            fromBlock = filter.fromBlock;\n\n            if (_.isNumber(fromBlock)) {\n              fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n\n            toBlock = filter.toBlock;\n\n            if (_.isNumber(toBlock)) {\n              toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n\n            serializedFilter = __assign({}, filter, {\n              fromBlock: fromBlock,\n              toBlock: toBlock\n            });\n            payload = {\n              method: 'eth_getLogs',\n              params: [serializedFilter]\n            };\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync(payload)];\n\n          case 1:\n            rawLogs = _a.sent();\n            formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return [2\n            /*return*/\n            , formattedLogs];\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n\n\n  Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, gasHex, gas;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_estimateGas',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            gasHex = _a.sent();\n            gas = utils_2.utils.convertHexToNumber(gasHex);\n            return [2\n            /*return*/\n            , gas];\n        }\n      });\n    });\n  };\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n\n\n  Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, callDataHex, rawCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_call',\n              params: [callDataHex, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            rawCallResult = _a.sent();\n            return [2\n            /*return*/\n            , rawCallResult];\n        }\n      });\n    });\n  };\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n\n\n  Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, txHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sendTransaction',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            txHash = _a.sent();\n            return [2\n            /*return*/\n            , txHash];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n\n            if (timeoutMs !== undefined) {\n              assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n\n            return [4\n            /*yield*/\n            , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n          case 1:\n            transactionReceipt = _a.sent();\n\n            if (transactionReceipt !== undefined) {\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                logs: logsWithDecodedArgs\n              });\n              return [2\n              /*return*/\n              , transactionReceiptWithDecodedLogArgs];\n            }\n\n            wasTimeoutExceeded = false;\n\n            if (timeoutMs) {\n              setTimeout(function () {\n                return wasTimeoutExceeded = true;\n              }, timeoutMs);\n            }\n\n            txReceiptPromise = new Promise(function (resolve, reject) {\n              var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        if (wasTimeoutExceeded) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return [2\n                          /*return*/\n                          , reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                        }\n\n                        return [4\n                        /*yield*/\n                        , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n                      case 1:\n                        transactionReceipt = _a.sent();\n\n                        if (transactionReceipt !== undefined) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                          transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                            logs: logsWithDecodedArgs\n                          });\n                          resolve(transactionReceiptWithDecodedLogArgs);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              }, pollingIntervalMs, function (err) {\n                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                reject(err);\n              });\n            });\n            return [4\n            /*yield*/\n            , txReceiptPromise];\n\n          case 2:\n            txReceipt = _a.sent();\n            return [2\n            /*return*/\n            , txReceipt];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var receipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n\n          case 1:\n            receipt = _a.sent();\n\n            if (receipt.status !== 1) {\n              throw new Error(\"Transaction failed: \" + txHash);\n            }\n\n            return [2\n            /*return*/\n            , receipt];\n        }\n      });\n    });\n  };\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n\n\n  Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_setHead',\n              params: [utils_2.utils.numberToHex(blockNumber)]\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n\n\n  Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sendAsync, payloadWithDefaults, response, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sendAsync = this._provider.sendAsync.bind(this._provider);\n            payloadWithDefaults = __assign({\n              id: this._jsonRpcRequestId++,\n              params: [],\n              jsonrpc: '2.0'\n            }, payload);\n            return [4\n            /*yield*/\n            , utils_1.promisify(sendAsync)(payloadWithDefaults)];\n\n          case 1:\n            response = _a.sent();\n\n            if (response.error) {\n              throw new Error(response.error.message);\n            }\n\n            result = response.result;\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n\n\n  Web3Wrapper.prototype.getNodeTypeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Geth];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Ganache];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\n\n\nexports.Web3Wrapper = Web3Wrapper;","map":{"version":3,"sources":["../../src/web3_wrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar marshaller_1 = require(\"./marshaller\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nvar uniqueVersionIds = {\n    geth: 'Geth',\n    ganache: 'EthereumJS TestRPC',\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nvar Web3Wrapper = /** @class */ (function () {\n    /**\n     * Instantiates a new Web3Wrapper.\n     * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n     *                      the backing Ethereum node.\n     * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n     * @return  An instance of the Web3Wrapper class.\n     */\n    function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n        if (callAndTxnDefaults === void 0) { callAndTxnDefaults = {}; }\n        /**\n         * Flag to check if this instance is of type Web3Wrapper\n         */\n        this.isZeroExWeb3Wrapper = true;\n        this.abiDecoder = new utils_1.AbiDecoder([]);\n        this._supportedProvider = supportedProvider;\n        this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._callAndTxnDefaults = callAndTxnDefaults;\n        this._jsonRpcRequestId = 1;\n    }\n    /**\n     * Check if an address is a valid Ethereum address\n     * @param address Address to check\n     * @returns Whether the address is a valid Ethereum address\n     */\n    Web3Wrapper.isAddress = function (address) {\n        return utils_1.addressUtils.isAddress(address);\n    };\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n    Web3Wrapper.toUnitAmount = function (amount, decimals) {\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var unit = amount.div(aUnit);\n        return unit;\n    };\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n    Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n        assert_1.assert.isBigNumber('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var baseUnitAmount = amount.times(unit);\n        var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n        if (hasDecimals) {\n            throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n        }\n        return baseUnitAmount;\n    };\n    /**\n     * Convert an Ether amount from ETH to Wei\n     * @param ethAmount Amount of Ether to convert to wei\n     * @returns Amount in wei\n     */\n    Web3Wrapper.toWei = function (ethAmount) {\n        assert_1.assert.isBigNumber('ethAmount', ethAmount);\n        var ETH_DECIMALS = 18;\n        var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n        return balanceWei;\n    };\n    Web3Wrapper._assertBlockParam = function (blockParam) {\n        if (_.isNumber(blockParam)) {\n            return;\n        }\n        else if (_.isString(blockParam)) {\n            assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n        }\n    };\n    Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n        try {\n            Web3Wrapper._assertBlockParam(blockParam);\n        }\n        catch (err) {\n            try {\n                assert_1.assert.isHexString('blockParam', blockParam);\n                return;\n            }\n            catch (err) {\n                throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n            }\n        }\n    };\n    Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n        // Transaction status might have four values\n        // undefined - Testrpc and other old clients\n        // null - New clients on old transactions\n        // number - Parity\n        // hex - Geth\n        if (_.isString(status)) {\n            return utils_2.utils.convertHexToNumber(status);\n        }\n        else if (status === undefined) {\n            return null;\n        }\n        else {\n            return status;\n        }\n    };\n    /**\n     * Get the contract defaults set to the Web3Wrapper instance\n     * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n     */\n    Web3Wrapper.prototype.getContractDefaults = function () {\n        return this._callAndTxnDefaults;\n    };\n    /**\n     * Retrieve the Web3 provider\n     * @return  Web3 provider instance\n     */\n    Web3Wrapper.prototype.getProvider = function () {\n        return this._supportedProvider;\n    };\n    /**\n     * Update the used Web3 provider\n     * @param provider The new Web3 provider to be set\n     */\n    Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n        var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._provider = provider;\n    };\n    /**\n     * Check whether an address is available through the backing provider. This can be\n     * useful if you want to know whether a user can sign messages or transactions from\n     * a given Ethereum address.\n     * @param senderAddress Address to check availability for\n     * @returns Whether the address is available through the provider.\n     */\n    Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n                        return [4 /*yield*/, this.getAvailableAddressesAsync()];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddress = senderAddress.toLowerCase();\n                        return [2 /*return*/, _.includes(addresses, normalizedAddress)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n     * @returns Ethereum node's version string\n     */\n    Web3Wrapper.prototype.getNodeVersionAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var nodeVersion;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'web3_clientVersion' })];\n                    case 1:\n                        nodeVersion = _a.sent();\n                        return [2 /*return*/, nodeVersion];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the networkId of the backing Ethereum node\n     * @returns The network id\n     */\n    Web3Wrapper.prototype.getNetworkIdAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var networkIdStr, networkId;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'net_version' })];\n                    case 1:\n                        networkIdStr = _a.sent();\n                        networkId = _.parseInt(networkIdStr);\n                        return [2 /*return*/, networkId];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction receipt for a given transaction hash if found\n     * @param txHash Transaction hash\n     * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n     */\n    Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceiptRpc, transactionReceipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionReceipt',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionReceiptRpc = _a.sent();\n                        // HACK Parity can return a pending transaction receipt. We check for a non null\n                        // block number before continuing with returning a fully realised receipt.\n                        // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n                        if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n                            transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n                            transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n                            return [2 /*return*/, transactionReceipt];\n                        }\n                        else {\n                            return [2 /*return*/, undefined];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction data for a given transaction\n     * @param txHash Transaction hash\n     * @returns The raw transaction data\n     */\n    Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionRpc, transaction;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionByHash',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionRpc = _a.sent();\n                        transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n                        return [2 /*return*/, transaction];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves an accounts Ether balance in wei\n     * @param owner Account whose balance you wish to check\n     * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n     * @returns Balance in wei\n     */\n    Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedOwner, balanceInWei;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('owner', owner);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getBalance',\n                                params: [encodedOwner, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        balanceInWei = _a.sent();\n                        // Rewrap in a new BigNumber\n                        return [2 /*return*/, new utils_1.BigNumber(balanceInWei)];\n                }\n            });\n        });\n    };\n    /**\n     * Check if a contract exists at a given address\n     * @param address Address to which to check\n     * @returns Whether or not contract code was found at the supplied address\n     */\n    Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var code, isCodeEmpty;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        return [4 /*yield*/, this.getContractCodeAsync(address)];\n                    case 1:\n                        code = _a.sent();\n                        isCodeEmpty = /^0x0{0,40}$/i.test(code);\n                        return [2 /*return*/, !isCodeEmpty];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the contract code by address\n     * @param  address Address of the contract\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @return Code of the contract\n     */\n    Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedAddress, code;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getCode',\n                                params: [encodedAddress, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        code = _a.sent();\n                        return [2 /*return*/, code];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the debug trace of a transaction\n     * @param  txHash Hash of the transactuon to get a trace for\n     * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n     * @return Transaction trace\n     */\n    Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var trace;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'debug_traceTransaction',\n                                params: [txHash, traceParams],\n                            })];\n                    case 1:\n                        trace = _a.sent();\n                        return [2 /*return*/, trace];\n                }\n            });\n        });\n    };\n    /**\n     * Sign a message with a specific address's private key (`eth_sign`)\n     * @param address Address of signer\n     * @param message Message to sign\n     * @returns Signature string (might be VRS or RSV depending on the Signer)\n     */\n    Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_sign',\n                                params: [address, message],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n     * @param address Address of signer\n     * @param typedData Typed data message to sign\n     * @returns Signature string (as RSV)\n     */\n    Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_signTypedData',\n                                params: [address, typedData],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the latest block number\n     * @returns Block number\n     */\n    Web3Wrapper.prototype.getBlockNumberAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumberHex, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_blockNumber',\n                            params: [],\n                        })];\n                    case 1:\n                        blockNumberHex = _a.sent();\n                        blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n                        return [2 /*return*/, blockNumber];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block without transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block without transaction data, or undefined if block was not found\n     * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n     */\n    Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = false;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n                        if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n                            blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n                        }\n                        return [2 /*return*/, blockWithoutTransactionDataIfExists];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block with transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block with transaction data\n     */\n    Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = blockParam;\n                        if (_.isNumber(blockParam)) {\n                            encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n                        }\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = true;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithTransactionDataWithHexValues = _a.sent();\n                        blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n                        return [2 /*return*/, blockWithoutTransactionData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a block's timestamp\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The block's timestamp\n     */\n    Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        return [4 /*yield*/, this.getBlockIfExistsAsync(blockParam)];\n                    case 1:\n                        blockIfExists = _a.sent();\n                        if (blockIfExists === undefined) {\n                            throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n                        }\n                        return [2 /*return*/, blockIfExists.timestamp];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve the user addresses available through the backing provider\n     * @returns Available user addresses\n     */\n    Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddresses;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_accounts',\n                            params: [],\n                        })];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddresses = _.map(addresses, function (address) { return address.toLowerCase(); });\n                        return [2 /*return*/, normalizedAddresses];\n                }\n            });\n        });\n    };\n    /**\n     * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n     * @returns The snapshot id. This can be used to revert to this snapshot\n     */\n    Web3Wrapper.prototype.takeSnapshotAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var snapshotId, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = Number;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_snapshot', params: [] })];\n                    case 1:\n                        snapshotId = _a.apply(void 0, [_b.sent()]);\n                        return [2 /*return*/, snapshotId];\n                }\n            });\n        });\n    };\n    /**\n     * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n     * @param snapshotId snapshot id to revert to\n     * @returns Whether the revert was successful\n     */\n    Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var didRevert;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('snapshotId', snapshotId);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_revert', params: [snapshotId] })];\n                    case 1:\n                        didRevert = _a.sent();\n                        return [2 /*return*/, didRevert];\n                }\n            });\n        });\n    };\n    /**\n     * Mine a block on a TestRPC/Ganache local node\n     */\n    Web3Wrapper.prototype.mineBlockAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_mine', params: [] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n     * Will throw if provider is neither TestRPC/Ganache or Geth.\n     * @param timeDelta Amount of time to add in seconds\n     */\n    Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('timeDelta', timeDelta);\n                        return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'debug_increaseTime', params: [timeDelta] })];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'evm_increaseTime', params: [timeDelta] })];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve smart contract logs for a given filter\n     * @param filter Parameters by which to filter which logs to retrieve\n     * @returns The corresponding log entries\n     */\n    Web3Wrapper.prototype.getLogsAsync = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n                            throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n                        }\n                        fromBlock = filter.fromBlock;\n                        if (_.isNumber(fromBlock)) {\n                            fromBlock = utils_2.utils.numberToHex(fromBlock);\n                        }\n                        toBlock = filter.toBlock;\n                        if (_.isNumber(toBlock)) {\n                            toBlock = utils_2.utils.numberToHex(toBlock);\n                        }\n                        serializedFilter = __assign({}, filter, { fromBlock: fromBlock,\n                            toBlock: toBlock });\n                        payload = {\n                            method: 'eth_getLogs',\n                            params: [serializedFilter],\n                        };\n                        return [4 /*yield*/, this.sendRawPayloadAsync(payload)];\n                    case 1:\n                        rawLogs = _a.sent();\n                        formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n                        return [2 /*return*/, formattedLogs];\n                }\n            });\n        });\n    };\n    /**\n     * Calculate the estimated gas cost for a given transaction\n     * @param txData Transaction data\n     * @returns Estimated gas cost\n     */\n    Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, gasHex, gas;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_estimateGas', params: [txDataHex] })];\n                    case 1:\n                        gasHex = _a.sent();\n                        gas = utils_2.utils.convertHexToNumber(gasHex);\n                        return [2 /*return*/, gas];\n                }\n            });\n        });\n    };\n    /**\n     * Call a smart contract method at a given block height\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns The raw call result\n     */\n    Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, callDataHex, rawCallResult;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_call',\n                                params: [callDataHex, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        rawCallResult = _a.sent();\n                        return [2 /*return*/, rawCallResult];\n                }\n            });\n        });\n    };\n    /**\n     * Send a transaction\n     * @param txData Transaction data\n     * @returns Transaction hash\n     */\n    Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, txHash;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_sendTransaction', params: [txDataHex] })];\n                    case 1:\n                        txHash = _a.sent();\n                        return [2 /*return*/, txHash];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Note that just because a transaction was mined does not mean it was\n     * successful. You need to check the status code of the transaction receipt\n     * to find out if it was successful, or use the helper method\n     * awaitTransactionSuccessAsync.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n                        if (timeoutMs !== undefined) {\n                            assert_1.assert.isNumber('timeoutMs', timeoutMs);\n                        }\n                        return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                    case 1:\n                        transactionReceipt = _a.sent();\n                        if (transactionReceipt !== undefined) {\n                            logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                            transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                            return [2 /*return*/, transactionReceiptWithDecodedLogArgs];\n                        }\n                        wasTimeoutExceeded = false;\n                        if (timeoutMs) {\n                            setTimeout(function () { return (wasTimeoutExceeded = true); }, timeoutMs);\n                        }\n                        txReceiptPromise = new Promise(function (resolve, reject) {\n                            var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            if (wasTimeoutExceeded) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                return [2 /*return*/, reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                                            }\n                                            return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                                        case 1:\n                                            transactionReceipt = _a.sent();\n                                            if (transactionReceipt !== undefined) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                                                transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                                                resolve(transactionReceiptWithDecodedLogArgs);\n                                            }\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            }); }, pollingIntervalMs, function (err) {\n                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                reject(err);\n                            });\n                        });\n                        return [4 /*yield*/, txReceiptPromise];\n                    case 2:\n                        txReceipt = _a.sent();\n                        return [2 /*return*/, txReceipt];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n     * status that is not equal to 1. A status of 0 or null indicates that the\n     * transaction was mined, but failed. See:\n     * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var receipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n                    case 1:\n                        receipt = _a.sent();\n                        if (receipt.status !== 1) {\n                            throw new Error(\"Transaction failed: \" + txHash);\n                        }\n                        return [2 /*return*/, receipt];\n                }\n            });\n        });\n    };\n    /**\n     * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n     * the local chain by block number. Note, this is a destructive action and\n     * may severely damage your chain. Use with extreme caution. As of now, this\n     * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n     * not supported.\n     * @param  blockNumber The block number to reset to.\n     */\n    Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('blockNumber', blockNumber);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'debug_setHead', params: [utils_2.utils.numberToHex(blockNumber)] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n     * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n     * @return The contents nested under the result key of the response body\n     */\n    Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sendAsync, payloadWithDefaults, response, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        sendAsync = this._provider.sendAsync.bind(this._provider);\n                        payloadWithDefaults = __assign({ id: this._jsonRpcRequestId++, params: [], jsonrpc: '2.0' }, payload);\n                        return [4 /*yield*/, utils_1.promisify(sendAsync)(payloadWithDefaults)];\n                    case 1:\n                        response = _a.sent();\n                        if (response.error) {\n                            throw new Error(response.error.message);\n                        }\n                        result = response.result;\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n     * the backing Ethereum node. Throws for any other type of node.\n     */\n    Web3Wrapper.prototype.getNodeTypeAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, types_1.NodeType.Geth];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, types_1.NodeType.Ganache];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Web3Wrapper;\n}()); // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;\n//# sourceMappingURL=web3_wrapper.js.map"]},"metadata":{},"sourceType":"script"}