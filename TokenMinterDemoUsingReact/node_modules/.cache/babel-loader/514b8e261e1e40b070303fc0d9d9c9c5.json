{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\"); // Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\n\n\nfunction parseEthersParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n} // returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\n\n\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n\n    var newType = _.trimEnd(type, '[]');\n\n    for (var i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    } // For tuples, we iterate through the underlying values and check each\n    // one individually.\n\n\n    var types = splitTupleTypes(type);\n\n    if (types.length !== name.names.length) {\n      throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      var nestedName = _.isString(name.names[i]) ? name.names[i] : name.names[i].name;\n\n      if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n\n  return _.isEqual(x, y);\n} // splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\n\n\nfunction splitTupleTypes(type) {\n  var e_1, _a;\n\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n  } // Trim the outtermost tuple().\n\n\n  var trimmedType = type.substring('tuple('.length, type.length - 1);\n  var types = [];\n  var currToken = '';\n  var parenCount = 0;\n\n  try {\n    // Tokenize the type string while keeping track of parentheses.\n    for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n      var char = trimmedType_1_1.value;\n\n      switch (char) {\n        case '(':\n          parenCount += 1;\n          currToken += char;\n          break;\n\n        case ')':\n          parenCount -= 1;\n          currToken += char;\n          break;\n\n        case ',':\n          if (parenCount === 0) {\n            types.push(currToken);\n            currToken = '';\n            break;\n          } else {\n            currToken += char;\n            break;\n          }\n\n        default:\n          currToken += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  types.push(currToken);\n  return types;\n}\n\nexports.abiUtils = {\n  parseEthersParams: parseEthersParams,\n  isAbiDataEqual: isAbiDataEqual,\n  splitTupleTypes: splitTupleTypes,\n  parseFunctionParam: function (param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      var tupleComponents = param.components;\n\n      var paramString = _.map(tupleComponents, function (component) {\n        return exports.abiUtils.parseFunctionParam(component);\n      });\n\n      var tupleParamString = \"{\" + paramString + \"}\";\n      return tupleParamString;\n    }\n\n    return param.type;\n  },\n  getFunctionSignature: function (methodAbi) {\n    var functionName = methodAbi.name;\n\n    var parameterTypeList = _.map(methodAbi.inputs, function (param) {\n      return exports.abiUtils.parseFunctionParam(param);\n    });\n\n    var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n    return functionSignature;\n  },\n\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods: function (inputContractAbi) {\n    var contractAbi = _.cloneDeep(inputContractAbi);\n\n    var methodAbis = contractAbi.filter(function (abi) {\n      return abi.type === ethereum_types_1.AbiType.Function;\n    }); // Sort method Abis into alphabetical order, by function signature\n\n    var methodAbisOrdered = _.sortBy(methodAbis, [function (methodAbi) {\n      var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]); // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n\n\n    var methodAbisByName = {};\n\n    _.each(methodAbisOrdered, function (methodAbi) {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    }); // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n\n\n    _.each(methodAbisByName, function (methodAbisWithSameName) {\n      _.each(methodAbisWithSameName, function (methodAbi, i) {\n        if (methodAbisWithSameName.length > 1) {\n          var overloadedMethodId = i + 1;\n          var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n\n          var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) {\n            return currentMethodAbi.name === sanitizedMethodName_1;\n          });\n\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            var methodName = methodAbi.name;\n            throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n          }\n\n          methodAbi.name = sanitizedMethodName_1;\n        }\n      });\n    });\n\n    return contractAbi;\n  }\n};","map":{"version":3,"mappings":"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","names":["parseEthersParams","params","names","types","forEach","param","components","suffix","arrayBracket","type","indexOf","substring","result","push","name","join","isAbiDataEqual","x","y","undefined","_","endsWith","length","newType","trimEnd","i","startsWith","isString","Error","splitTupleTypes","nestedName","isEqual","toLower","configured_bignumber_1","eq","trimmedType","currToken","parenCount","trimmedType_1_1","char","exports","parseFunctionParam","tupleComponents","paramString","map","component","tupleParamString","getFunctionSignature","methodAbi","functionName","parameterTypeList","inputs","functionSignature","renameOverloadedMethods","inputContractAbi","contractAbi","cloneDeep","methodAbis","filter","abi","ethereum_types_1","Function","methodAbisOrdered","sortBy","methodAbisByName","each","methodAbisWithSameName","overloadedMethodId","sanitizedMethodName_1","indexOfExistingAbiWithSanitizedMethodNameIfExists","findIndex","methodName"],"sources":["../../src/abi_utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}