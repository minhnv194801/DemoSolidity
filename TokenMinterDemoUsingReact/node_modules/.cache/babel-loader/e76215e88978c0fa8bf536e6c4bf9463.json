{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nexports.providerUtils = {\n  /**\n   * Starts the Web3ProviderEngine without excess block polling\n   * @param providerEngine The Web3ProviderEngine\n   */\n  startProviderEngine: function (providerEngine) {\n    if (providerEngine.start === undefined) {\n      throw new Error(\"Invalid Web3ProviderEngine\");\n    } // HACK: When calling start() Web3ProviderEngine starts a block polling service\n    // this continuously pulls data from the network and can result in high data usage\n    // for long running services. If used in a front end application this can cause\n    // a high amount of load on a node (one request per user per block).\n\n\n    providerEngine._ready.go();\n\n    providerEngine._running = true;\n  },\n\n  /**\n   * Standardize the supported provider types into our internal provider interface\n   * or throw if unsupported provider supplied.\n   * @param supportedProvider Potentially supported provider instance\n   * @return Provider that conforms of our internal provider interface\n   */\n  standardizeOrThrow: function (supportedProvider) {\n    if (supportedProvider === undefined) {\n      throw new Error(\"supportedProvider cannot be 'undefined'\");\n    }\n\n    var provider = {\n      isStandardizedProvider: true,\n      isMetaMask: supportedProvider.isMetaMask,\n      isParity: supportedProvider.isParity,\n      stop: supportedProvider.stop,\n      enable: supportedProvider.enable,\n      sendAsync: _.noop.bind(_)\n    }; // Case 1: We've already converted to our ZeroExProvider so noop.\n\n    if (supportedProvider.isStandardizedProvider) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return supportedProvider; // Case 2: It's a compliant EIP 1193 Provider\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n    } else if (supportedProvider.isEIP1193) {\n      provider.sendAsync = function (payload, callback) {\n        var method = payload.method;\n        var params = payload.params;\n        supportedProvider.send(method, params).then(function (result) {\n          callback(null, result);\n        }).catch(function (err) {\n          callback(err);\n        });\n      };\n\n      return provider; // Case 3: The provider has a `sendAsync` method, so we use it.\n    } else if (supportedProvider.sendAsync !== undefined) {\n      provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n      return provider; // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n    } else if (supportedProvider.send !== undefined) {\n      // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n      // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n      if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n        provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n        return provider;\n      } else {\n        // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n        // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n        provider.sendAsync = function (payload, callback) {\n          var method = payload.method;\n          var params = payload.params;\n          supportedProvider.send(method, params).then(function (result) {\n            callback(null, result);\n          }).catch(function (err) {\n            callback(err);\n          });\n        };\n\n        return provider;\n      }\n    }\n\n    throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n  }\n};","map":{"version":3,"sources":["../../src/provider_utils.ts"],"names":[],"mappings":";;;;;;AAOA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEa,OAAA,CAAA,aAAA,GAAgB;EACzB;;;AAGG;EACH,mBAAmB,EAAnB,UAAoB,cAApB,EAAuC;IACnC,IAAI,cAAc,CAAC,KAAf,KAAyB,SAA7B,EAAwC;MACpC,MAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;IACH,CAHkC,CAInC;IACA;IACA;IACA;;;IACA,cAAc,CAAC,MAAf,CAAsB,EAAtB;;IACA,cAAc,CAAC,QAAf,GAA0B,IAA1B;EACH,CAfwB;;EAgBzB;;;;;AAKG;EACH,kBAAkB,EAAlB,UAAmB,iBAAnB,EAAuD;IACnD,IAAI,iBAAiB,KAAK,SAA1B,EAAqC;MACjC,MAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;IACH;;IACD,IAAM,QAAQ,GAAG;MACb,sBAAsB,EAAE,IADX;MAEb,UAAU,EAAG,iBAAyB,CAAC,UAF1B;MAGb,QAAQ,EAAG,iBAAyB,CAAC,QAHxB;MAIb,IAAI,EAAG,iBAAyB,CAAC,IAJpB;MAKb,MAAM,EAAG,iBAAyB,CAAC,MALtB;MAMb,SAAS,EAAE,CAAC,CAAC,IAAF,CAAO,IAAP,CAAY,CAAZ;IANE,CAAjB,CAJmD,CAYnD;;IACA,IAAK,iBAAyB,CAAC,sBAA/B,EAAuD;MACnD;MACA,OAAO,iBAAP,CAFmD,CAGnD;MACA;IACH,CALD,MAKO,IAAK,iBAAqC,CAAC,SAA3C,EAAsD;MACzD,QAAQ,CAAC,SAAT,GAAqB,UAAC,OAAD,EAAiC,QAAjC,EAA+D;QAChF,IAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;QACA,IAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;QACC,iBAAyB,CACrB,IADJ,CACS,MADT,EACiB,MADjB,EAEI,IAFJ,CAES,UAAC,MAAD,EAAY;UACd,QAAQ,CAAC,IAAD,EAAO,MAAP,CAAR;QACH,CAJJ,EAKI,KALJ,CAKU,UAAC,GAAD,EAAW;UACd,QAAQ,CAAC,GAAD,CAAR;QACH,CAPJ;MAQJ,CAXD;;MAYA,OAAO,QAAP,CAbyD,CAczD;IACH,CAfM,MAeA,IAAK,iBAAyB,CAAC,SAA1B,KAAwC,SAA7C,EAAwD;MAC3D,QAAQ,CAAC,SAAT,GAAsB,iBAAyB,CAAC,SAA1B,CAAoC,IAApC,CAAyC,iBAAzC,CAAtB;MACA,OAAO,QAAP,CAF2D,CAG3D;IACH,CAJM,MAIA,IAAK,iBAAyB,CAAC,IAA1B,KAAmC,SAAxC,EAAmD;MACtD;MACA;MACA,IAAI,CAAC,CAAC,QAAF,CAAY,iBAAyB,CAAC,IAA1B,CAA+B,QAA/B,EAAZ,EAAuD,8BAAvD,CAAJ,EAA4F;QACxF,QAAQ,CAAC,SAAT,GAAsB,iBAAyB,CAAC,IAA1B,CAA+B,IAA/B,CAAoC,iBAApC,CAAtB;QACA,OAAO,QAAP;MACH,CAHD,MAGO;QACH;QACA;QACA,QAAQ,CAAC,SAAT,GAAqB,UAAC,OAAD,EAAiC,QAAjC,EAA+D;UAChF,IAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;UACA,IAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;UACC,iBAAyB,CACrB,IADJ,CACS,MADT,EACiB,MADjB,EAEI,IAFJ,CAES,UAAC,MAAD,EAAY;YACd,QAAQ,CAAC,IAAD,EAAO,MAAP,CAAR;UACH,CAJJ,EAKI,KALJ,CAKU,UAAC,GAAD,EAAW;YACd,QAAQ,CAAC,GAAD,CAAR;UACH,CAPJ;QAQJ,CAXD;;QAYA,OAAO,QAAP;MACH;IACJ;;IACD,MAAM,IAAI,KAAJ,CACF,8IADE,CAAN;EAGH;AAtFwB,CAAhB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nexports.providerUtils = {\n    /**\n     * Starts the Web3ProviderEngine without excess block polling\n     * @param providerEngine The Web3ProviderEngine\n     */\n    startProviderEngine: function (providerEngine) {\n        if (providerEngine.start === undefined) {\n            throw new Error(\"Invalid Web3ProviderEngine\");\n        }\n        // HACK: When calling start() Web3ProviderEngine starts a block polling service\n        // this continuously pulls data from the network and can result in high data usage\n        // for long running services. If used in a front end application this can cause\n        // a high amount of load on a node (one request per user per block).\n        providerEngine._ready.go();\n        providerEngine._running = true;\n    },\n    /**\n     * Standardize the supported provider types into our internal provider interface\n     * or throw if unsupported provider supplied.\n     * @param supportedProvider Potentially supported provider instance\n     * @return Provider that conforms of our internal provider interface\n     */\n    standardizeOrThrow: function (supportedProvider) {\n        if (supportedProvider === undefined) {\n            throw new Error(\"supportedProvider cannot be 'undefined'\");\n        }\n        var provider = {\n            isStandardizedProvider: true,\n            isMetaMask: supportedProvider.isMetaMask,\n            isParity: supportedProvider.isParity,\n            stop: supportedProvider.stop,\n            enable: supportedProvider.enable,\n            sendAsync: _.noop.bind(_),\n        };\n        // Case 1: We've already converted to our ZeroExProvider so noop.\n        if (supportedProvider.isStandardizedProvider) {\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n            return supportedProvider;\n            // Case 2: It's a compliant EIP 1193 Provider\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n        }\n        else if (supportedProvider.isEIP1193) {\n            provider.sendAsync = function (payload, callback) {\n                var method = payload.method;\n                var params = payload.params;\n                supportedProvider\n                    .send(method, params)\n                    .then(function (result) {\n                    callback(null, result);\n                })\n                    .catch(function (err) {\n                    callback(err);\n                });\n            };\n            return provider;\n            // Case 3: The provider has a `sendAsync` method, so we use it.\n        }\n        else if (supportedProvider.sendAsync !== undefined) {\n            provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n            return provider;\n            // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n        }\n        else if (supportedProvider.send !== undefined) {\n            // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n            // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n            if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n                provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n                return provider;\n            }\n            else {\n                // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n                // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n                provider.sendAsync = function (payload, callback) {\n                    var method = payload.method;\n                    var params = payload.params;\n                    supportedProvider\n                        .send(method, params)\n                        .then(function (result) {\n                        callback(null, result);\n                    })\n                        .catch(function (err) {\n                        callback(err);\n                    });\n                };\n                return provider;\n            }\n        }\n        throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n    },\n};\n//# sourceMappingURL=provider_utils.js.map"]},"metadata":{},"sourceType":"script"}