{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar queue_1 = require(\"../utils/queue\");\n\nvar RawCalldata =\n/** @class */\nfunction () {\n  function RawCalldata(value, hasSelector) {\n    if (hasSelector === void 0) {\n      hasSelector = true;\n    } // Sanity check\n\n\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    } // Construct initial values\n\n\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n\n    this._offset = RawCalldata._INITIAL_OFFSET; // If there's a selector then slice it\n\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n\n  RawCalldata.prototype.popBytes = function (lengthInBytes) {\n    var popBegin = this._offset;\n    var popEnd = popBegin + lengthInBytes;\n\n    if (popEnd > this._value.byteLength) {\n      throw new Error(\"Tried to decode beyond the end of calldata\");\n    }\n\n    var value = this._value.slice(popBegin, popEnd);\n\n    this.setOffset(popEnd);\n    return value;\n  };\n\n  RawCalldata.prototype.popWord = function () {\n    var wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  };\n\n  RawCalldata.prototype.popWords = function (length) {\n    var wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  };\n\n  RawCalldata.prototype.readBytes = function (from, to) {\n    var value = this._value.slice(from, to);\n\n    return value;\n  };\n\n  RawCalldata.prototype.setOffset = function (offsetInBytes) {\n    this._offset = offsetInBytes;\n  };\n\n  RawCalldata.prototype.startScope = function () {\n    this._scopes.pushFront(this._offset);\n  };\n\n  RawCalldata.prototype.endScope = function () {\n    this._scopes.popFront();\n  };\n\n  RawCalldata.prototype.getOffset = function () {\n    return this._offset;\n  };\n\n  RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n    var scopeOffset = this._scopes.peekFront();\n\n    if (scopeOffset === undefined) {\n      throw new Error(\"Tried to access undefined scope.\");\n    }\n\n    var absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  };\n\n  RawCalldata.prototype.getSelector = function () {\n    return this._selector;\n  };\n\n  RawCalldata.prototype.getSizeInBytes = function () {\n    var sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  };\n\n  RawCalldata._INITIAL_OFFSET = 0;\n  return RawCalldata;\n}();\n\nexports.RawCalldata = RawCalldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/raw_calldata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar queue_1 = require(\"../utils/queue\");\nvar RawCalldata = /** @class */ (function () {\n    function RawCalldata(value, hasSelector) {\n        if (hasSelector === void 0) { hasSelector = true; }\n        // Sanity check\n        if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n            throw new Error(\"Expected raw calldata to start with '0x'\");\n        }\n        // Construct initial values\n        this._value = ethUtil.toBuffer(value);\n        this._selector = '0x';\n        this._scopes = new queue_1.Queue();\n        this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n        this._offset = RawCalldata._INITIAL_OFFSET;\n        // If there's a selector then slice it\n        if (hasSelector) {\n            var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._selector = ethUtil.bufferToHex(selectorBuf);\n        }\n    }\n    RawCalldata.prototype.popBytes = function (lengthInBytes) {\n        var popBegin = this._offset;\n        var popEnd = popBegin + lengthInBytes;\n        if (popEnd > this._value.byteLength) {\n            throw new Error(\"Tried to decode beyond the end of calldata\");\n        }\n        var value = this._value.slice(popBegin, popEnd);\n        this.setOffset(popEnd);\n        return value;\n    };\n    RawCalldata.prototype.popWord = function () {\n        var wordInBytes = 32;\n        return this.popBytes(wordInBytes);\n    };\n    RawCalldata.prototype.popWords = function (length) {\n        var wordInBytes = 32;\n        return this.popBytes(length * wordInBytes);\n    };\n    RawCalldata.prototype.readBytes = function (from, to) {\n        var value = this._value.slice(from, to);\n        return value;\n    };\n    RawCalldata.prototype.setOffset = function (offsetInBytes) {\n        this._offset = offsetInBytes;\n    };\n    RawCalldata.prototype.startScope = function () {\n        this._scopes.pushFront(this._offset);\n    };\n    RawCalldata.prototype.endScope = function () {\n        this._scopes.popFront();\n    };\n    RawCalldata.prototype.getOffset = function () {\n        return this._offset;\n    };\n    RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n        var scopeOffset = this._scopes.peekFront();\n        if (scopeOffset === undefined) {\n            throw new Error(\"Tried to access undefined scope.\");\n        }\n        var absoluteOffset = relativeOffset + scopeOffset;\n        return absoluteOffset;\n    };\n    RawCalldata.prototype.getSelector = function () {\n        return this._selector;\n    };\n    RawCalldata.prototype.getSizeInBytes = function () {\n        var sizeInBytes = this._value.byteLength;\n        return sizeInBytes;\n    };\n    RawCalldata._INITIAL_OFFSET = 0;\n    return RawCalldata;\n}());\nexports.RawCalldata = RawCalldata;\n//# sourceMappingURL=raw_calldata.js.map"]},"metadata":{},"sourceType":"script"}