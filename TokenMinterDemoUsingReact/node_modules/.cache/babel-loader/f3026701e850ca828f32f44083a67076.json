{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar ethers = require(\"ethers\");\n\nvar _ = require(\"lodash\");\n\nvar _1 = require(\".\");\n\nvar address_utils_1 = require(\"./address_utils\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * AbiDecoder allows you to decode event logs given a set of supplied contract ABI's. It takes the contract's event\n * signature from the ABI and attempts to decode the logs using it.\n */\n\n\nvar AbiDecoder =\n/** @class */\nfunction () {\n  /**\n   * Instantiate an AbiDecoder\n   * @param abiArrays An array of contract ABI's\n   * @return AbiDecoder instance\n   */\n  function AbiDecoder(abiArrays) {\n    var _this = this;\n\n    this._eventIds = {};\n    this._selectorToFunctionInfo = {};\n\n    _.each(abiArrays, function (abi) {\n      _this.addABI(abi);\n    });\n  }\n  /**\n   * Retrieves the function selector from calldata.\n   * @param calldata hex-encoded calldata.\n   * @return hex-encoded function selector.\n   */\n\n\n  AbiDecoder._getFunctionSelector = function (calldata) {\n    var functionSelectorLength = 10;\n\n    if (!calldata.startsWith('0x') || calldata.length < functionSelectorLength) {\n      throw new Error(\"Malformed calldata. Must include a hex prefix '0x' and 4-byte function selector. Got '\" + calldata + \"'\");\n    }\n\n    var functionSelector = calldata.substr(0, functionSelectorLength);\n    return functionSelector;\n  };\n  /**\n   * Attempt to decode a log given the ABI's the AbiDecoder knows about.\n   * @param log The log to attempt to decode\n   * @return The decoded log if the requisite ABI was available. Otherwise the log unaltered.\n   */\n\n\n  AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n    var eventId = log.topics[0];\n    var numIndexedArgs = log.topics.length - 1;\n\n    if (this._eventIds[eventId] === undefined || this._eventIds[eventId][numIndexedArgs] === undefined) {\n      return log;\n    }\n\n    var event = this._eventIds[eventId][numIndexedArgs];\n    var ethersInterface = new ethers.utils.Interface([event]);\n    var decodedParams = {};\n    var topicsIndex = 1;\n    var decodedData;\n\n    try {\n      decodedData = ethersInterface.events[event.name].decode(log.data);\n    } catch (error) {\n      if (error.code === ethers.errors.INVALID_ARGUMENT) {\n        // Because we index events by Method ID, and Method IDs are derived from the method\n        // name and the input parameters, it's possible that the return value of the event\n        // does not match our ABI. If that's the case, then ethers will throw an error\n        // when we try to parse the event. We handle that case here by returning the log rather\n        // than throwing an error.\n        return log;\n      }\n\n      throw error;\n    }\n\n    var didFailToDecode = false;\n\n    _.forEach(event.inputs, function (param, i) {\n      // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n      var value = param.indexed ? log.topics[topicsIndex++] : decodedData[i];\n\n      if (value === undefined) {\n        didFailToDecode = true;\n        return;\n      }\n\n      if (param.type === ethereum_types_1.SolidityTypes.Address) {\n        var baseHex = 16;\n        value = address_utils_1.addressUtils.padZeros(new configured_bignumber_1.BigNumber(value.toLowerCase()).toString(baseHex));\n      } else if (param.type === ethereum_types_1.SolidityTypes.Uint256 || param.type === ethereum_types_1.SolidityTypes.Uint) {\n        value = new configured_bignumber_1.BigNumber(value);\n      } else if (param.type === ethereum_types_1.SolidityTypes.Uint8) {\n        value = new configured_bignumber_1.BigNumber(value).toNumber();\n      }\n\n      decodedParams[param.name] = value;\n    });\n\n    if (didFailToDecode) {\n      return log;\n    } else {\n      return __assign({}, log, {\n        event: event.name,\n        args: decodedParams\n      });\n    }\n  };\n  /**\n   * Decodes calldata for a known ABI.\n   * @param calldata hex-encoded calldata.\n   * @param contractName used to disambiguate similar ABI's (optional).\n   * @return Decoded calldata. Includes: function name and signature, along with the decoded arguments.\n   */\n\n\n  AbiDecoder.prototype.decodeCalldataOrThrow = function (calldata, contractName) {\n    var functionSelector = AbiDecoder._getFunctionSelector(calldata);\n\n    var candidateFunctionInfos = this._selectorToFunctionInfo[functionSelector];\n\n    if (candidateFunctionInfos === undefined) {\n      throw new Error(\"No functions registered for selector '\" + functionSelector + \"'\");\n    }\n\n    var functionInfo = _.find(candidateFunctionInfos, function (candidateFunctionInfo) {\n      return contractName === undefined || _.toLower(contractName) === _.toLower(candidateFunctionInfo.contractName);\n    });\n\n    if (functionInfo === undefined) {\n      throw new Error(\"No function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n    } else if (functionInfo.abiEncoder === undefined) {\n      throw new Error(\"Function ABI Encoder is not defined, for function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n    }\n\n    var functionName = functionInfo.abiEncoder.getDataItem().name;\n    var functionSignature = functionInfo.abiEncoder.getSignatureType();\n    var functionArguments = functionInfo.abiEncoder.decode(calldata);\n    var decodedCalldata = {\n      functionName: functionName,\n      functionSignature: functionSignature,\n      functionArguments: functionArguments\n    };\n    return decodedCalldata;\n  };\n  /**\n   * Adds a set of ABI definitions, after which calldata and logs targeting these ABI's can be decoded.\n   * Additional properties can be included to disambiguate similar ABI's. For example, if two functions\n   * have the same signature but different parameter names, then their ABI definitions can be disambiguated\n   * by specifying a contract name.\n   * @param abiDefinitions ABI definitions for a given contract.\n   * @param contractName Name of contract that encapsulates the ABI definitions (optional).\n   *                     This can be used when decoding calldata to disambiguate methods with\n   *                     the same signature but different parameter names.\n   */\n\n\n  AbiDecoder.prototype.addABI = function (abiArray, contractName) {\n    var _this = this;\n\n    if (abiArray === undefined) {\n      return;\n    }\n\n    var ethersInterface = new ethers.utils.Interface(abiArray);\n\n    _.map(abiArray, function (abi) {\n      switch (abi.type) {\n        case ethereum_types_1.AbiType.Event:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          _this._addEventABI(abi, ethersInterface);\n\n          break;\n\n        case ethereum_types_1.AbiType.Function:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          _this._addMethodABI(abi, contractName);\n\n          break;\n\n        default:\n          // ignore other types\n          break;\n      }\n    });\n  };\n\n  AbiDecoder.prototype._addEventABI = function (eventAbi, ethersInterface) {\n    var _a;\n\n    var topic = ethersInterface.events[eventAbi.name].topic;\n\n    var numIndexedArgs = _.reduce(eventAbi.inputs, function (sum, input) {\n      return input.indexed ? sum + 1 : sum;\n    }, 0);\n\n    this._eventIds[topic] = __assign({}, this._eventIds[topic], (_a = {}, _a[numIndexedArgs] = eventAbi, _a));\n  };\n\n  AbiDecoder.prototype._addMethodABI = function (methodAbi, contractName) {\n    var abiEncoder = new _1.AbiEncoder.Method(methodAbi);\n    var functionSelector = abiEncoder.getSelector();\n\n    if (!(functionSelector in this._selectorToFunctionInfo)) {\n      this._selectorToFunctionInfo[functionSelector] = [];\n    } // Recored a copy of this ABI for each deployment\n\n\n    var functionSignature = abiEncoder.getSignature();\n\n    this._selectorToFunctionInfo[functionSelector].push({\n      functionSignature: functionSignature,\n      abiEncoder: abiEncoder,\n      contractName: contractName\n    });\n  };\n\n  return AbiDecoder;\n}();\n\nexports.AbiDecoder = AbiDecoder;","map":{"version":3,"mappings":"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","names":["abiArrays","_","each","_this","addABI","abi","AbiDecoder","calldata","functionSelectorLength","startsWith","length","Error","functionSelector","substr","log","eventId","topics","numIndexedArgs","_eventIds","undefined","event","ethersInterface","ethers","utils","Interface","decodedParams","topicsIndex","decodedData","events","name","decode","data","error","code","errors","INVALID_ARGUMENT","didFailToDecode","forEach","inputs","param","i","value","indexed","type","ethereum_types_1","Address","baseHex","address_utils_1","padZeros","configured_bignumber_1","toLowerCase","toString","Uint256","Uint","Uint8","toNumber","args","contractName","_getFunctionSelector","candidateFunctionInfos","_selectorToFunctionInfo","functionInfo","find","toLower","candidateFunctionInfo","abiEncoder","functionName","getDataItem","functionSignature","getSignatureType","functionArguments","decodedCalldata","abiArray","map","Event","_addEventABI","Function","_addMethodABI","eventAbi","topic","reduce","sum","input","__assign","_a","methodAbi","_1","Method","getSelector","getSignature","push","exports"],"sources":["../../src/abi_decoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}