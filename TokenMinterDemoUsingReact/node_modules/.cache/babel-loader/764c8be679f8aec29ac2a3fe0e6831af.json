{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n/** @type ValidatorResult */\n\n\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\n\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n/**\n * @name validators\n */\n\nvar validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if (!v) return;\n      var id = v.$id || v.id;\n      return id ? '<' + id + '>' : v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema) {\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n\n  return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\n\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n\n  if (!schema.anyOf.some(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if (id) return '<' + id + '>';\n      return v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n\n    if (!valid.valid) {\n      var id = v.$id || v.id;\n      var msg = id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.if = function validateIf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n\n  if (ifValid) {\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  } else {\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n\n  return result;\n};\n\nfunction getEnumerableProperty(object, key) {\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if (Object.hasOwnProperty.call(object, key)) return object[key]; // Test `key in object` as an optimization; false means it won't\n\n  if (!(key in object)) return;\n\n  while (object = Object.getPrototypeOf(object)) {\n    if (Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames !== undefined ? schema.propertyNames : {};\n  if (!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if (getEnumerableProperty(instance, property) !== undefined) {\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n\n  for (var property in properties) {\n    var subschema = properties[property];\n\n    if (subschema === undefined) {\n      continue;\n    } else if (subschema === null) {\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n\n  return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\n\n\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (!this.types.object(instance)) return;\n\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property)\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n\n      if (subschema === undefined) {\n        continue;\n      } else if (subschema === null) {\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch (_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n\n      if (!regexp.test(property)) {\n        continue;\n      }\n\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return; // if patternProperties is defined then we'll test when that one is called instead\n\n  if (schema.patternProperties) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;\n\n    if (items === undefined) {\n      return true;\n    }\n\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if (!(instance > schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum\n      });\n    }\n  } else {\n    if (!(instance >= schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if (!(instance < schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum\n      });\n    }\n  } else {\n    if (!(instance <= schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if (typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum\n    });\n  }\n\n  return result;\n};\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if (typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum\n    });\n  }\n\n  return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\n\n\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n  var validationArgument = schema[validationType];\n\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (getEnumerableProperty(instance, n) === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch (_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString())\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\n\n\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx); // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n\n  return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\n\n\nfunction testArrays(v, i, a) {\n  var j,\n      len = a.length;\n\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (schema.uniqueItems !== true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;","map":{"version":3,"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","$id","addError","name","argument","message","testSchemaNoThrow","callback","throwError","throwAll","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","if","validateIf","isSchema","Error","ifValid","call","then","makeChild","else","getEnumerableProperty","object","key","Object","hasOwnProperty","getPrototypeOf","propertyIsEnumerable","propertyNames","validatePropertyNames","subschema","property","properties","validateProperties","preValidateProperty","prop","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","test","pattern","regexp","RegExp","_e","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","array","every","value","additionalItems","minimum","validateMinimum","number","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateExclusiveMinimum","validateExclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","string","match","toString","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","hsp","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","testArrays","a","j","len","deepCompareStrict","uniqueItems","validateUniqueItems","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","String","not","disallow","validateNot","notTypes","schemaId","module","exports"],"sources":["D:/Blockchain/test-react/node_modules/jsonschema/lib/attribute.js"],"sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true,\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if(!v) return;\n      var id = v.$id || v.id;\n      return id ? ('<' + id + '>') : (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n    ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if(id) return '<' + id + '>';\n      return(v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var id = v.$id || v.id;\n      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n    ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.if = function validateIf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n  if(ifValid){\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  }else{\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n  return result;\n};\n\nfunction getEnumerableProperty(object, key){\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if(Object.hasOwnProperty.call(object, key)) return object[key];\n  // Test `key in object` as an optimization; false means it won't\n  if(!(key in object)) return;\n  while( (object = Object.getPrototypeOf(object)) ){\n    if(Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};\n  if(!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if(getEnumerableProperty(instance, property) !== undefined){\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var subschema = properties[property];\n    if(subschema===undefined){\n      continue;\n    }else if(subschema===null){\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property),\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n      if(subschema===undefined){\n        continue;\n      }else if(subschema===null){\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch(_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n      if (!regexp.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if(!(instance > schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum,\n      });\n    }\n  } else {\n    if(!(instance >= schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if(!(instance < schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum,\n      });\n    }\n  } else {\n    if(!(instance <= schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument),\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\",\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(getEnumerableProperty(instance, n)===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch(_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (schema.uniqueItems!==true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}