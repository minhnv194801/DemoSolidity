{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar blob_1 = require(\"../abstract_data_types/types/blob\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar AddressDataType =\n/** @class */\nfunction (_super) {\n  __extends(AddressDataType, _super);\n\n  function AddressDataType(dataItem, dataTypeFactory) {\n    var _this = _super.call(this, dataItem, dataTypeFactory, AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME) || this;\n\n    if (!AddressDataType.matchType(dataItem.type)) {\n      throw new Error(\"Tried to instantiate Address with bad input: \" + dataItem);\n    }\n\n    return _this;\n  }\n\n  AddressDataType.matchType = function (type) {\n    return type === ethereum_types_1.SolidityTypes.Address;\n  }; // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  AddressDataType.prototype.encodeValue = function (value) {\n    if (!ethUtil.isValidAddress(value)) {\n      throw new Error(\"Invalid address: '\" + value + \"'\");\n    }\n\n    var valueBuf = ethUtil.toBuffer(value);\n    var encodedValueBuf = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return encodedValueBuf;\n  };\n\n  AddressDataType.prototype.decodeValue = function (calldata) {\n    var valueBufPadded = calldata.popWord();\n    var valueBuf = valueBufPadded.slice(AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES);\n    var value = ethUtil.bufferToHex(valueBuf);\n\n    var valueLowercase = _.toLower(value);\n\n    return valueLowercase;\n  };\n\n  AddressDataType.prototype.getDefaultValue = function () {\n    return AddressDataType._DEFAULT_VALUE;\n  };\n\n  AddressDataType.prototype.getSignatureType = function () {\n    return ethereum_types_1.SolidityTypes.Address;\n  };\n\n  AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\n  AddressDataType._ADDRESS_SIZE_IN_BYTES = 20;\n  AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES - AddressDataType._ADDRESS_SIZE_IN_BYTES;\n  AddressDataType._DEFAULT_VALUE = '0x0000000000000000000000000000000000000000';\n  return AddressDataType;\n}(blob_1.AbstractBlobDataType);\n\nexports.AddressDataType = AddressDataType;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAGA;;AAEA;;AAEA;AAAA;AAAA;EAAqCA;;EAWjC,yBAAmBC,QAAnB,EAAuCC,eAAvC,EAAuE;IAAvE,YACIC,kBAAMF,QAAN,EAAgBC,eAAhB,EAAiCE,eAAe,CAACC,2BAAjD,KAA6E,IADjF;;IAEI,IAAI,CAACD,eAAe,CAACE,SAAhB,CAA0BL,QAAQ,CAACM,IAAnC,CAAL,EAA+C;MAC3C,MAAM,IAAIC,KAAJ,CAAU,kDAAgDP,QAA1D,CAAN;IACH;;;EACJ;;EATaG,4BAAd,UAAwBG,IAAxB,EAAoC;IAChC,OAAOA,IAAI,KAAKE,+BAAcC,OAA9B;EACH,CAFa,CAPlB,CAkBI;;EACA;;;EACON,wCAAP,UAAmBO,KAAnB,EAAgC;IAC5B,IAAI,CAACC,OAAO,CAACC,cAAR,CAAuBF,KAAvB,CAAL,EAAoC;MAChC,MAAM,IAAIH,KAAJ,CAAU,uBAAqBG,KAArB,GAA0B,GAApC,CAAN;IACH;;IACD,IAAMG,QAAQ,GAAGF,OAAO,CAACG,QAAR,CAAiBJ,KAAjB,CAAjB;IACA,IAAMK,eAAe,GAAGJ,OAAO,CAACK,aAAR,CAAsBH,QAAtB,EAAgCI,sBAAUC,uBAA1C,CAAxB;IACA,OAAOH,eAAP;EACH,CAPM;;EASAZ,wCAAP,UAAmBgB,QAAnB,EAAwC;IACpC,IAAMC,cAAc,GAAGD,QAAQ,CAACE,OAAT,EAAvB;IACA,IAAMR,QAAQ,GAAGO,cAAc,CAACE,KAAf,CAAqBnB,eAAe,CAACoB,gCAArC,CAAjB;IACA,IAAMb,KAAK,GAAGC,OAAO,CAACa,WAAR,CAAoBX,QAApB,CAAd;;IACA,IAAMY,cAAc,GAAGC,CAAC,CAACC,OAAF,CAAUjB,KAAV,CAAvB;;IACA,OAAOe,cAAP;EACH,CANM;;EAQAtB,4CAAP;IACI,OAAOA,eAAe,CAACyB,cAAvB;EACH,CAFM;;EAIAzB,6CAAP;IACI,OAAOK,+BAAcC,OAArB;EACH,CAFM;;EAxCiBN,8CAAuC,IAAvC;EACAA,yCAAyB,EAAzB;EACAA,mDACpBc,sBAAUC,uBAAV,GAAoCf,eAAe,CAAC0B,sBADhC;EAEA1B,iCAAiB,4CAAjB;EAwC5B;AAAC,CA7CD,CAAqC2B,2BAArC;;AAAaC","names":["__extends","dataItem","dataTypeFactory","_super","AddressDataType","_SIZE_KNOWN_AT_COMPILE_TIME","matchType","type","Error","ethereum_types_1","Address","value","ethUtil","isValidAddress","valueBuf","toBuffer","encodedValueBuf","setLengthLeft","constants_1","EVM_WORD_WIDTH_IN_BYTES","calldata","valueBufPadded","popWord","slice","_DECODED_ADDRESS_OFFSET_IN_BYTES","bufferToHex","valueLowercase","_","toLower","_DEFAULT_VALUE","_ADDRESS_SIZE_IN_BYTES","blob_1","exports"],"sources":["../../../../src/abi_encoder/evm_data_types/address.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}