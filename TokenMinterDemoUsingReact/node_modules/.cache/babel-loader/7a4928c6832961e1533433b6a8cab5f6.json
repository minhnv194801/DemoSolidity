{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nfunction parseNode(node) {\n  var components = [];\n\n  _.each(node.children, function (child) {\n    var component = parseNode(child);\n    components.push(component);\n  });\n\n  var dataItem = {\n    name: node.name,\n    type: node.value\n  };\n\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\n\n\nfunction generateDataItemFromSignature(signature) {\n  var e_1, _a; // No data item corresponds to an empty signature\n\n\n  if (_.isEmpty(signature)) {\n    throw new Error(\"Cannot parse data item from empty signature, ''\");\n  } // Create a parse tree for data item\n\n\n  var node = {\n    name: '',\n    value: '',\n    children: []\n  };\n\n  try {\n    for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n      var char = signature_1_1.value;\n\n      switch (char) {\n        case '(':\n          var child = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node\n          };\n          node.value = 'tuple';\n          node.children.push(child);\n          node = child;\n          break;\n\n        case ')':\n          node = node.parent;\n          break;\n\n        case ',':\n          var sibling = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node.parent\n          };\n          node.parent.children.push(sibling);\n          node = sibling;\n          break;\n\n        case ' ':\n          node.name = node.value;\n          node.value = '';\n          break;\n\n        default:\n          node.value += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  } // Interpret data item from parse tree\n\n\n  var dataItem = parseNode(node);\n  return dataItem;\n}\n\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;AACA;;AASA,SAASA,SAAT,CAAmBC,IAAnB,EAA6B;EACzB,IAAMC,UAAU,GAAe,EAA/B;;EACAC,CAAC,CAACC,IAAF,CAAOH,IAAI,CAACI,QAAZ,EAAsB,UAACC,KAAD,EAAY;IAC9B,IAAMC,SAAS,GAAGP,SAAS,CAACM,KAAD,CAA3B;IACAJ,UAAU,CAACM,IAAX,CAAgBD,SAAhB;EACH,CAHD;;EAIA,IAAME,QAAQ,GAAa;IACvBC,IAAI,EAAET,IAAI,CAACS,IADY;IAEvBC,IAAI,EAAEV,IAAI,CAACW;EAFY,CAA3B;;EAIA,IAAI,CAACT,CAAC,CAACU,OAAF,CAAUX,UAAV,CAAL,EAA4B;IACxBO,QAAQ,CAACP,UAAT,GAAsBA,UAAtB;EACH;;EACD,OAAOO,QAAP;AACH;AAED;;;;;;;;;;AAQA,SAAgBK,6BAAhB,CAA8CC,SAA9C,EAA+D;cAAA,CAC3D;;;EACA,IAAIZ,CAAC,CAACU,OAAF,CAAUE,SAAV,CAAJ,EAA0B;IACtB,MAAM,IAAIC,KAAJ,CAAU,iDAAV,CAAN;EACH,CAJ0D,CAK3D;;;EACA,IAAIf,IAAI,GAAS;IACbS,IAAI,EAAE,EADO;IAEbE,KAAK,EAAE,EAFM;IAGbP,QAAQ,EAAE;EAHG,CAAjB;;;IAKA,KAAmB,uCAASY,kCAA5B,EAA4B,mBAA5B,EAA4BA,kCAA5B,EAA8B;MAAzB,IAAMC,IAAI,sBAAV;;MACD,QAAQA,IAAR;QACI,KAAK,GAAL;UACI,IAAMZ,KAAK,GAAG;YACVI,IAAI,EAAE,EADI;YAEVE,KAAK,EAAE,EAFG;YAGVP,QAAQ,EAAE,EAHA;YAIVc,MAAM,EAAElB;UAJE,CAAd;UAMAA,IAAI,CAACW,KAAL,GAAa,OAAb;UACAX,IAAI,CAACI,QAAL,CAAcG,IAAd,CAAmBF,KAAnB;UACAL,IAAI,GAAGK,KAAP;UACA;;QAEJ,KAAK,GAAL;UACIL,IAAI,GAAGA,IAAI,CAACkB,MAAZ;UACA;;QAEJ,KAAK,GAAL;UACI,IAAMC,OAAO,GAAG;YACZV,IAAI,EAAE,EADM;YAEZE,KAAK,EAAE,EAFK;YAGZP,QAAQ,EAAE,EAHE;YAIZc,MAAM,EAAElB,IAAI,CAACkB;UAJD,CAAhB;UAMClB,IAAI,CAACkB,MAAL,CAAqBd,QAArB,CAA8BG,IAA9B,CAAmCY,OAAnC;UACDnB,IAAI,GAAGmB,OAAP;UACA;;QAEJ,KAAK,GAAL;UACInB,IAAI,CAACS,IAAL,GAAYT,IAAI,CAACW,KAAjB;UACAX,IAAI,CAACW,KAAL,GAAa,EAAb;UACA;;QAEJ;UACIX,IAAI,CAACW,KAAL,IAAcM,IAAd;UACA;MAnCR;IAqCH;;;;;;;;;;;GAjD0D,CAkD3D;;;EACA,IAAMT,QAAQ,GAAGT,SAAS,CAACC,IAAD,CAA1B;EACA,OAAOQ,QAAP;AACH;;AArDDY","names":["parseNode","node","components","_","each","children","child","component","push","dataItem","name","type","value","isEmpty","generateDataItemFromSignature","signature","Error","signature_1_1","char","parent","sibling","exports"],"sources":["../../../../src/abi_encoder/utils/signature_parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}