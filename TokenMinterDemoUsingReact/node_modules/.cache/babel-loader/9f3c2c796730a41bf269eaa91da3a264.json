{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* eslint-disable no-continue */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-prototype-builtins */\n\n\nvar errorClasses = {};\nvar deserializers = {};\n\nvar addCustomErrorDeserializer = exports.addCustomErrorDeserializer = function addCustomErrorDeserializer(name, deserializer) {\n  deserializers[name] = deserializer;\n};\n\nvar createCustomErrorClass = exports.createCustomErrorClass = function createCustomErrorClass(name) {\n  var C = function CustomError(message, fields) {\n    Object.assign(this, fields);\n    this.name = name;\n    this.message = message || name;\n    this.stack = new Error().stack;\n  }; // $FlowFixMe\n\n\n  C.prototype = new Error();\n  errorClasses[name] = C; // $FlowFixMe we can't easily type a subset of Error for now...\n\n  return C;\n}; // inspired from https://github.com/programble/errio/blob/master/index.js\n\n\nvar deserializeError = exports.deserializeError = function deserializeError(object) {\n  if ((typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) === \"object\" && object) {\n    try {\n      // $FlowFixMe FIXME HACK\n      var msg = JSON.parse(object.message);\n\n      if (msg.message && msg.name) {\n        object = msg;\n      }\n    } catch (e) {// nothing\n    }\n\n    var error = void 0;\n\n    if (typeof object.name === \"string\") {\n      var _object = object,\n          name = _object.name;\n      var des = deserializers[name];\n\n      if (des) {\n        error = des(object);\n      } else {\n        var _constructor = name === \"Error\" ? Error : errorClasses[name];\n\n        if (!_constructor) {\n          console.warn(\"deserializing an unknown class '\" + name + \"'\");\n          _constructor = createCustomErrorClass(name);\n        }\n\n        error = Object.create(_constructor.prototype);\n\n        try {\n          for (var prop in object) {\n            if (object.hasOwnProperty(prop)) {\n              error[prop] = object[prop];\n            }\n          }\n        } catch (e) {// sometimes setting a property can fail (e.g. .name)\n        }\n      }\n    } else {\n      error = new Error(object.message);\n    }\n\n    if (!error.stack && Error.captureStackTrace) {\n      Error.captureStackTrace(error, deserializeError);\n    }\n\n    return error;\n  }\n\n  return new Error(String(object));\n}; // inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\n\n\nvar serializeError = exports.serializeError = function serializeError(value) {\n  if (!value) return value;\n\n  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\") {\n    return destroyCircular(value, []);\n  }\n\n  if (typeof value === \"function\") {\n    return \"[Function: \" + (value.name || \"anonymous\") + \"]\";\n  }\n\n  return value;\n}; // https://www.npmjs.com/package/destroy-circular\n\n\nfunction destroyCircular(from, seen) {\n  var to = {};\n  seen.push(from);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      var value = from[key];\n\n      if (typeof value === \"function\") {\n        continue;\n      }\n\n      if (!value || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") {\n        to[key] = value;\n        continue;\n      }\n\n      if (seen.indexOf(from[key]) === -1) {\n        to[key] = destroyCircular(from[key], seen.slice(0));\n        continue;\n      }\n\n      to[key] = \"[Circular]\";\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (typeof from.name === \"string\") {\n    to.name = from.name;\n  }\n\n  if (typeof from.message === \"string\") {\n    to.message = from.message;\n  }\n\n  if (typeof from.stack === \"string\") {\n    to.stack = from.stack;\n  }\n\n  return to;\n}","map":{"version":3,"mappings":"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","names":["errorClasses","deserializers","addCustomErrorDeserializer","name","deserializer","createCustomErrorClass","C","CustomError","message","fields","Object","assign","stack","Error","prototype","deserializeError","object","msg","JSON","parse","e","error","des","constructor","console","warn","create","prop","hasOwnProperty","captureStackTrace","String","serializeError","value","destroyCircular","from","seen","to","push","keys","Symbol","key","indexOf","slice","_didIteratorError","_iteratorError","_iterator"],"sources":["D:\\Blockchain\\test-react\\node_modules\\@ledgerhq\\errors\\src\\helpers.js"],"sourcesContent":["// @flow\n/* eslint-disable no-continue */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-prototype-builtins */\n\nconst errorClasses = {};\nconst deserializers = {};\n\nexport const addCustomErrorDeserializer = (\n  name: string,\n  deserializer: Object => *\n) => {\n  deserializers[name] = deserializer;\n};\n\nexport const createCustomErrorClass = (name: string): Class<any> => {\n  const C = function CustomError(message?: string, fields?: Object) {\n    Object.assign(this, fields);\n    this.name = name;\n    this.message = message || name;\n    this.stack = new Error().stack;\n  };\n  // $FlowFixMe\n  C.prototype = new Error();\n\n  errorClasses[name] = C;\n  // $FlowFixMe we can't easily type a subset of Error for now...\n  return C;\n};\n\n// inspired from https://github.com/programble/errio/blob/master/index.js\nexport const deserializeError = (object: mixed): Error => {\n  if (typeof object === \"object\" && object) {\n    try {\n      // $FlowFixMe FIXME HACK\n      const msg = JSON.parse(object.message);\n      if (msg.message && msg.name) {\n        object = msg;\n      }\n    } catch (e) {\n      // nothing\n    }\n\n    let error;\n    if (typeof object.name === \"string\") {\n      const { name } = object;\n      const des = deserializers[name];\n      if (des) {\n        error = des(object);\n      } else {\n        let constructor = name === \"Error\" ? Error : errorClasses[name];\n\n        if (!constructor) {\n          console.warn(\"deserializing an unknown class '\" + name + \"'\");\n          constructor = createCustomErrorClass(name);\n        }\n\n        error = Object.create(constructor.prototype);\n        try {\n          for (const prop in object) {\n            if (object.hasOwnProperty(prop)) {\n              error[prop] = object[prop];\n            }\n          }\n        } catch (e) {\n          // sometimes setting a property can fail (e.g. .name)\n        }\n      }\n    } else {\n      error = new Error(object.message);\n    }\n\n    if (!error.stack && Error.captureStackTrace) {\n      Error.captureStackTrace(error, deserializeError);\n    }\n    return error;\n  }\n  return new Error(String(object));\n};\n\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\nexport const serializeError = (value: mixed) => {\n  if (!value) return value;\n  if (typeof value === \"object\") {\n    return destroyCircular(value, []);\n  }\n  if (typeof value === \"function\") {\n    return `[Function: ${value.name || \"anonymous\"}]`;\n  }\n  return value;\n};\n\n// https://www.npmjs.com/package/destroy-circular\nfunction destroyCircular(from: Object, seen) {\n  const to = {};\n  seen.push(from);\n  for (const key of Object.keys(from)) {\n    const value = from[key];\n    if (typeof value === \"function\") {\n      continue;\n    }\n    if (!value || typeof value !== \"object\") {\n      to[key] = value;\n      continue;\n    }\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0));\n      continue;\n    }\n    to[key] = \"[Circular]\";\n  }\n  if (typeof from.name === \"string\") {\n    to.name = from.name;\n  }\n  if (typeof from.message === \"string\") {\n    to.message = from.message;\n  }\n  if (typeof from.stack === \"string\") {\n    to.stack = from.stack;\n  }\n  return to;\n}\n"]},"metadata":{},"sourceType":"script"}