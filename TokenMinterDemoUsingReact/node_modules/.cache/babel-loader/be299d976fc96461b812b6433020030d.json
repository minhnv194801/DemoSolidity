{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar pointer_1 = require(\"./blocks/pointer\");\n\nvar set_1 = require(\"./blocks/set\");\n\nvar iterator_1 = require(\"./iterator\");\n\nvar Calldata =\n/** @class */\nfunction () {\n  function Calldata(rules) {\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n\n\n  Calldata.prototype.setRoot = function (block) {\n    this._root = block;\n  };\n  /**\n   * Sets the selector to be prepended onto the calldata.\n   * If the root block was created by a Method then a selector will likely be set.\n   */\n\n\n  Calldata.prototype.setSelector = function (selector) {\n    if (!_.startsWith(selector, '0x')) {\n      throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n    } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n      throw new Error(\"Invalid selector '\" + selector + \"'\");\n    }\n\n    this._selector = selector;\n  };\n  /**\n   * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n   * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n   * If the `annotate` flag is set then this will return human-readable calldata.\n   * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n   */\n\n\n  Calldata.prototype.toString = function () {\n    var e_1, _a; // Sanity check: root block must be set\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Optimize, if flag set\n\n\n    if (this._rules.shouldOptimize) {\n      this._optimize();\n    } // Set offsets\n\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    var offset = 0;\n\n    try {\n      for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n        var block = iterator_2_1.value;\n        block.setOffset(offset);\n        offset += block.getSizeInBytes();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Generate hex string\n\n\n    var hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n    return hexString;\n  };\n  /**\n   * There are three types of calldata blocks: Blob, Set and Pointer.\n   * Scenarios arise where distinct pointers resolve to identical values.\n   * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n   * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n   *\n   * Example #1:\n   *  function f(string[], string[])\n   *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n   *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n   *\n   * Example #2:\n   *  function f(string[], string)\n   *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n   *  The string \"foo\" will only be included in the calldata once.\n   *\n   * Example #3:\n   *  function f((string, uint, bytes), string, uint, bytes)\n   *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n   *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n   *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n   *\n   * @TODO #1:\n   *   This optimization strategy handles blocks that are exact duplicates of one another.\n   *   But what if some block is a combination of two other blocks? Or a subset of another block?\n   *   This optimization problem is not much different from the current implemetation.\n   *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n   *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n   *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n   *   This shouldn't be a problem but further investigation should be done.\n   *\n   * @TODO #2:\n   *   To be done as a follow-up to @TODO #1.\n   *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n   *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n   *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n   *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n   *\n   */\n\n\n  Calldata.prototype._optimize = function () {\n    var e_2, _a; // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n\n    var iterator = new iterator_1.ReverseCalldataIterator(this._root); // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n\n    var blocksByHash = {};\n\n    try {\n      for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n        var block = iterator_3_1.value; // If a block is a pointer and its value has already been observed, then update\n        // the pointer to resolve to the existing value.\n\n        if (block instanceof pointer_1.PointerCalldataBlock) {\n          var dependencyBlockHashBuf = block.getDependency().computeHash();\n          var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n\n          if (dependencyBlockHash in blocksByHash) {\n            var blockWithSameHash = blocksByHash[dependencyBlockHash];\n\n            if (blockWithSameHash !== block.getDependency()) {\n              block.setAlias(blockWithSameHash);\n            }\n          }\n\n          continue;\n        } // This block has not been seen. Record its hash.\n\n\n        var blockHashBuf = block.computeHash();\n        var blockHash = ethUtil.bufferToHex(blockHashBuf);\n\n        if (!(blockHash in blocksByHash)) {\n          blocksByHash[blockHash] = block;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n    var e_3, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Construct an array of buffers (one buffer for each block).\n\n\n    var selectorBuffer = ethUtil.toBuffer(this._selector);\n    var valueBufs = [selectorBuffer];\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n        var block = iterator_4_1.value;\n        valueBufs.push(block.toBuffer());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    } // Create hex from buffer array.\n\n\n    var combinedBuffers = Buffer.concat(valueBufs);\n    var hexValue = ethUtil.bufferToHex(combinedBuffers);\n    return hexValue;\n  };\n  /**\n   * Returns human-readable calldata.\n   *\n   * Example:\n   *   simpleFunction(string[], string[])\n   *   strings = [\"Hello\", \"World\"]\n   *   simpleFunction(strings, strings)\n   *\n   * Output:\n   *   0xbb4f12e3\n   *                                                                                      ### simpleFunction\n   *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n   *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n   *\n   *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n   *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n   *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n   *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n   *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n   *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n   *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n   */\n\n\n  Calldata.prototype._toHumanReadableCallData = function () {\n    var e_4, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Constants for constructing annotated string\n\n\n    var offsetPadding = 10;\n    var valuePadding = 74;\n    var namePadding = 80;\n    var evmWordStartIndex = 0;\n    var emptySize = 0; // Construct annotated calldata\n\n    var hexValue = \"\" + this._selector;\n    var offset = 0;\n\n    var functionName = this._root.getName();\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n        var block = iterator_5_1.value; // Process each block 1 word at a time\n\n        var size = block.getSizeInBytes();\n        var name_1 = block.getName();\n        var parentName = block.getParentName();\n        var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", ''); // Resulting line will be <offsetStr><valueStr><nameStr>\n\n        var offsetStr = '';\n        var valueStr = '';\n        var nameStr = '';\n        var lineStr = '';\n\n        if (size === emptySize) {\n          // This is a Set block with no header.\n          // For example, a tuple or an array with a defined length.\n          offsetStr = ' '.repeat(offsetPadding);\n          valueStr = ' '.repeat(valuePadding);\n          nameStr = \"### \" + prettyName.padEnd(namePadding);\n          lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n        } else {\n          // This block has at least one word of value.\n          offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n\n          if (block instanceof set_1.SetCalldataBlock) {\n            nameStr = \"### \" + prettyName.padEnd(namePadding);\n            lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n          } else {\n            nameStr = \"    \" + prettyName.padEnd(namePadding);\n            lineStr = \"\" + offsetStr + valueStr + nameStr;\n          }\n        } // This block has a value that is more than 1 word.\n\n\n        for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n          offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n          nameStr = ' '.repeat(namePadding);\n          lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n        } // Append to hex value\n\n\n        hexValue = hexValue + \"\\n\" + lineStr;\n        offset += size;\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return hexValue;\n  };\n\n  return Calldata;\n}();\n\nexports.Calldata = Calldata;","map":{"version":3,"mappings":"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","names":["rules","_rules","_selector","_root","undefined","Calldata","block","selector","_","startsWith","Error","length","constants_1","HEX_SELECTOR_LENGTH_IN_CHARS","shouldOptimize","_optimize","iterator","iterator_1","offset","iterator_2_1","setOffset","getSizeInBytes","hexString","shouldAnnotate","_toHumanReadableCallData","_toEvmCompatibeCallDataHex","blocksByHash","iterator_3_1","pointer_1","dependencyBlockHashBuf","getDependency","computeHash","dependencyBlockHash","ethUtil","bufferToHex","blockWithSameHash","setAlias","blockHashBuf","blockHash","selectorBuffer","toBuffer","valueBufs","iterator_4_1","push","combinedBuffers","Buffer","concat","hexValue","offsetPadding","valuePadding","namePadding","evmWordStartIndex","emptySize","functionName","getName","iterator_5_1","size","name_1","parentName","getParentName","prettyName","replace","offsetStr","valueStr","nameStr","lineStr","repeat","padEnd","toString","HEX_BASE","stripHexPrefix","slice","EVM_WORD_WIDTH_IN_BYTES","set_1","j","exports"],"sources":["../../../../src/abi_encoder/calldata/calldata.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}