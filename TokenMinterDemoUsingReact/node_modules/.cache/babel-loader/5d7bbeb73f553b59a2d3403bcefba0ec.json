{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t;\n  return {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  };\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [0, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nexports.__esModule = true;\n/** Class representing a semaphore\n * Semaphores are initialized with a number of permits that get aquired and released\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\n * executing until a permit becomes available.\n *\n * Locks that only allow one execution of a critical section are a special case of\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\n *\n * This Semaphore class is implemented with the help of promises that get returned\n * by functions that wait for permits to become available. This makes it possible\n * to use async/await to synchronize your code.\n */\n\nvar Semaphore = function () {\n  /**\n   * Creates a semaphore.\n   * @param permits  The number of permits, i.e. things being allowed to run in parallel.\n   * To create a lock that only lets one thing run at a time, set this to 1.\n   * This number can also be negative.\n   */\n  function Semaphore(permits) {\n    this.promiseResolverQueue = [];\n    this.permits = permits;\n  }\n  /**\n   * Returns the number of available permits.\n   * @returns  The number of available permits.\n   */\n\n\n  Semaphore.prototype.getPermits = function () {\n    return this.permits;\n  };\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n\n\n  Semaphore.prototype.wait = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        } // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n\n\n        return [2\n        /*return*/\n        , new Promise(function (resolver) {\n          return _this.promiseResolverQueue.push(resolver);\n        })];\n      });\n    });\n  };\n  /**\n   * Alias for {@linkcode Semaphore.wait}.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n\n\n  Semaphore.prototype.acquire = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.wait()];\n      });\n    });\n  };\n  /**\n   * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\n   * permit becomes available in time.\n   * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\n   * don't rely on it being precise.\n   * @returns  A promise that gets resolved with true when execution is allowed to proceed or\n   * false if the time given elapses before a permit becomes available.\n   */\n\n\n  Semaphore.prototype.waitFor = function (milliseconds) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var resolver, promise;\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        }\n\n        resolver = function (b) {\n          return void 0;\n        };\n\n        promise = new Promise(function (r) {\n          resolver = r;\n        }); // The saved resolver gets added to our list of promise resolvers so that it gets a chance\n        // to be resolved as a result of a call to signal().\n\n        this.promiseResolverQueue.push(resolver);\n        setTimeout(function () {\n          // We have to remove the promise resolver from our list. Resolving it twice would not be\n          // an issue but signal() always takes the next resolver from the queue and resolves it which\n          // would swallow a permit if we didn't remove it.\n          var index = _this.promiseResolverQueue.indexOf(resolver);\n\n          if (index !== -1) {\n            _this.promiseResolverQueue.splice(index, 1);\n          } else {// This is weird... TODO Think about what the best course of action would be at this point.\n            // Probably do nothing.\n          } // false because the wait was unsuccessful.\n\n\n          resolver(false);\n        }, milliseconds);\n        return [2\n        /*return*/\n        , promise];\n      });\n    });\n  };\n  /**\n   * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\n   * @returns  Whether a permit could be acquired.\n   */\n\n\n  Semaphore.prototype.tryAcquire = function () {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Acquires all permits that are currently available and returns the number of acquired permits.\n   * @returns  Number of acquired permits.\n   */\n\n\n  Semaphore.prototype.drainPermits = function () {\n    if (this.permits > 0) {\n      var permitCount = this.permits;\n      this.permits = 0;\n      return permitCount;\n    }\n\n    return 0;\n  };\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n\n\n  Semaphore.prototype.signal = function () {\n    this.permits += 1;\n\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      throw new Error('this.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      var nextResolver = this.promiseResolverQueue.shift();\n\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  };\n  /**\n   * Alias for {@linkcode Semaphore.signal}.\n   */\n\n\n  Semaphore.prototype.release = function () {\n    this.signal();\n  };\n  /**\n   * Schedules func to be called once a permit becomes available.\n   * Returns a promise that resolves to the return value of func.\n   * @typeparam T  The return type of func.\n   * @param func  The function to be executed.\n   * @return  A promise that gets resolved with the return value of the function.\n   */\n\n\n  Semaphore.prototype.execute = function (func) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.wait()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2,, 4, 5]);\n\n            return [4\n            /*yield*/\n            , func()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            this.signal();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Semaphore;\n}();\n\nexports[\"default\"] = Semaphore;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","verb","n","v","op","TypeError","call","pop","length","push","exports","__esModule","Semaphore","permits","promiseResolverQueue","prototype","getPermits","wait","_this","_a","resolver","acquire","waitFor","milliseconds","promise","b","r","setTimeout","index","indexOf","splice","tryAcquire","drainPermits","permitCount","signal","Error","nextResolver","shift","release","execute","func"],"sources":["D:/Blockchain/test-react/node_modules/semaphore-async-await/dist/Semaphore.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;\n    return { next: verb(0), \"throw\": verb(1), \"return\": verb(2) };\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\n/** Class representing a semaphore\n * Semaphores are initialized with a number of permits that get aquired and released\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\n * executing until a permit becomes available.\n *\n * Locks that only allow one execution of a critical section are a special case of\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\n *\n * This Semaphore class is implemented with the help of promises that get returned\n * by functions that wait for permits to become available. This makes it possible\n * to use async/await to synchronize your code.\n */\nvar Semaphore = (function () {\n    /**\n     * Creates a semaphore.\n     * @param permits  The number of permits, i.e. things being allowed to run in parallel.\n     * To create a lock that only lets one thing run at a time, set this to 1.\n     * This number can also be negative.\n     */\n    function Semaphore(permits) {\n        this.promiseResolverQueue = [];\n        this.permits = permits;\n    }\n    /**\n     * Returns the number of available permits.\n     * @returns  The number of available permits.\n     */\n    Semaphore.prototype.getPermits = function () {\n        return this.permits;\n    };\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    Semaphore.prototype.wait = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (this.permits > 0) {\n                    this.permits -= 1;\n                    return [2 /*return*/, Promise.resolve(true)];\n                }\n                // If there is no permit available, we return a promise that resolves once the semaphore gets\n                // signaled enough times that permits is equal to one.\n                return [2 /*return*/, new Promise(function (resolver) { return _this.promiseResolverQueue.push(resolver); })];\n            });\n        });\n    };\n    /**\n     * Alias for {@linkcode Semaphore.wait}.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    Semaphore.prototype.acquire = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.wait()];\n            });\n        });\n    };\n    /**\n     * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\n     * permit becomes available in time.\n     * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\n     * don't rely on it being precise.\n     * @returns  A promise that gets resolved with true when execution is allowed to proceed or\n     * false if the time given elapses before a permit becomes available.\n     */\n    Semaphore.prototype.waitFor = function (milliseconds) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var resolver, promise;\n            return __generator(this, function (_a) {\n                if (this.permits > 0) {\n                    this.permits -= 1;\n                    return [2 /*return*/, Promise.resolve(true)];\n                }\n                resolver = function (b) { return void (0); };\n                promise = new Promise(function (r) {\n                    resolver = r;\n                });\n                // The saved resolver gets added to our list of promise resolvers so that it gets a chance\n                // to be resolved as a result of a call to signal().\n                this.promiseResolverQueue.push(resolver);\n                setTimeout(function () {\n                    // We have to remove the promise resolver from our list. Resolving it twice would not be\n                    // an issue but signal() always takes the next resolver from the queue and resolves it which\n                    // would swallow a permit if we didn't remove it.\n                    var index = _this.promiseResolverQueue.indexOf(resolver);\n                    if (index !== -1) {\n                        _this.promiseResolverQueue.splice(index, 1);\n                    }\n                    else {\n                        // This is weird... TODO Think about what the best course of action would be at this point.\n                        // Probably do nothing.\n                    }\n                    // false because the wait was unsuccessful.\n                    resolver(false);\n                }, milliseconds);\n                return [2 /*return*/, promise];\n            });\n        });\n    };\n    /**\n     * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\n     * @returns  Whether a permit could be acquired.\n     */\n    Semaphore.prototype.tryAcquire = function () {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Acquires all permits that are currently available and returns the number of acquired permits.\n     * @returns  Number of acquired permits.\n     */\n    Semaphore.prototype.drainPermits = function () {\n        if (this.permits > 0) {\n            var permitCount = this.permits;\n            this.permits = 0;\n            return permitCount;\n        }\n        return 0;\n    };\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    Semaphore.prototype.signal = function () {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            throw new Error('this.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            var nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    };\n    /**\n     * Alias for {@linkcode Semaphore.signal}.\n     */\n    Semaphore.prototype.release = function () {\n        this.signal();\n    };\n    /**\n     * Schedules func to be called once a permit becomes available.\n     * Returns a promise that resolves to the return value of func.\n     * @typeparam T  The return type of func.\n     * @param func  The function to be executed.\n     * @return  A promise that gets resolved with the return value of the function.\n     */\n    Semaphore.prototype.execute = function (func) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.wait()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, , 4, 5]);\n                        return [4 /*yield*/, func()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                    case 4:\n                        this.signal();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Semaphore;\n}());\nexports[\"default\"] = Semaphore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}