{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\n  } else if (value.isNaN()) {\n    throw new Error(\"Tried to assign NaN value\");\n  }\n}\n\nfunction bigNumberToPaddedBuffer(value) {\n  var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\n  var valueBuf = ethUtil.toBuffer(valueHex);\n  var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n  return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\n\nfunction encodeNumericValue(value_) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10); // Case 1/2: value is non-negative\n\n  if (value.isGreaterThanOrEqualTo(0)) {\n    var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  } // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n\n\n  var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE); // Step 2/3: Invert binary value\n\n  var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 3/3: Add 1 to inverted value\n\n  var negativeValue = invertedValue.plus(1);\n  var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\n\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  var encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\n\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction decodeNumericValue(encodedValue, minValue) {\n  var valueHex = ethUtil.bufferToHex(encodedValue); // Case 1/3: value is definitely non-negative because of numeric boundaries\n\n  var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n  if (!minValue.isLessThan(0)) {\n    return value;\n  } // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n\n\n  var valueBin = value.toString(constants_1.constants.BIN_BASE);\n\n  var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n\n  if (!isValueNegative) {\n    return value;\n  } // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n\n\n  var invertedValueBin = '';\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n\n  var positiveValue = invertedValue.plus(1); // Step 3/3: Invert positive value to get the negative value\n\n  var negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\n\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  var value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\n\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":{"version":3,"mappings":"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","names":["sanityCheckBigNumberRange","value_","minValue","maxValue","value","configured_bignumber_1","isGreaterThan","Error","isLessThan","isNaN","bigNumberToPaddedBuffer","valueHex","toString","constants_1","HEX_BASE","valueBuf","ethUtil","toBuffer","valueBufPadded","setLengthLeft","EVM_WORD_WIDTH_IN_BYTES","encodeNumericValue","isGreaterThanOrEqualTo","encodedPositiveValue","valueBin","times","BIN_BASE","invertedValueBin","repeat","EVM_WORD_WIDTH_IN_BITS","length","_","each","bit","invertedValue","negativeValue","plus","encodedValue","exports","safeEncodeNumericValue","decodeNumericValue","bufferToHex","isValueNegative","startsWith","positiveValue","safeDecodeNumericValue"],"sources":["../../../../src/abi_encoder/utils/math.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}