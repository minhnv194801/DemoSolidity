{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"@0x/assert\");\n\nvar json_schemas_1 = require(\"@0x/json-schemas\");\n\nvar utils_1 = require(\"@0x/utils\");\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar marshaller_1 = require(\"./marshaller\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_2 = require(\"./utils\");\n\nvar BASE_TEN = 10; // These are unique identifiers contained in the response of the\n// web3_clientVersion call.\n\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\n\nvar Web3Wrapper =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n    if (callAndTxnDefaults === void 0) {\n      callAndTxnDefaults = {};\n    }\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n\n\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n\n\n  Web3Wrapper.isAddress = function (address) {\n    return utils_1.addressUtils.isAddress(address);\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  Web3Wrapper.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n\n\n  Web3Wrapper.toWei = function (ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    var ETH_DECIMALS = 18;\n    var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  };\n\n  Web3Wrapper._assertBlockParam = function (blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  };\n\n  Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n      }\n    }\n  };\n\n  Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  };\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getContractDefaults = function () {\n    return this._callAndTxnDefaults;\n  };\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n\n\n  Web3Wrapper.prototype.getProvider = function () {\n    return this._supportedProvider;\n  };\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n\n\n  Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n    var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  };\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n\n\n  Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            return [4\n            /*yield*/\n            , this.getAvailableAddressesAsync()];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddress = senderAddress.toLowerCase();\n            return [2\n            /*return*/\n            , _.includes(addresses, normalizedAddress)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n\n\n  Web3Wrapper.prototype.getNodeVersionAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nodeVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'web3_clientVersion'\n            })];\n\n          case 1:\n            nodeVersion = _a.sent();\n            return [2\n            /*return*/\n            , nodeVersion];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n\n\n  Web3Wrapper.prototype.getNetworkIdAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var networkIdStr, networkId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'net_version'\n            })];\n\n          case 1:\n            networkIdStr = _a.sent();\n            networkId = _.parseInt(networkIdStr);\n            return [2\n            /*return*/\n            , networkId];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n\n\n  Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceiptRpc, transactionReceipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionReceipt',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionReceiptRpc = _a.sent(); // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return [2\n              /*return*/\n              , transactionReceipt];\n            } else {\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n\n\n  Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionRpc, transaction;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionByHash',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionRpc = _a.sent();\n            transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return [2\n            /*return*/\n            , transaction];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n\n\n  Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedOwner, balanceInWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('owner', owner);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getBalance',\n              params: [encodedOwner, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            balanceInWei = _a.sent(); // Rewrap in a new BigNumber\n\n            return [2\n            /*return*/\n            , new utils_1.BigNumber(balanceInWei)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n\n\n  Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var code, isCodeEmpty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            return [4\n            /*yield*/\n            , this.getContractCodeAsync(address)];\n\n          case 1:\n            code = _a.sent();\n            isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return [2\n            /*return*/\n            , !isCodeEmpty];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n\n\n  Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedAddress, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getCode',\n              params: [encodedAddress, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            code = _a.sent();\n            return [2\n            /*return*/\n            , code];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n\n\n  Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trace;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_traceTransaction',\n              params: [txHash, traceParams]\n            })];\n\n          case 1:\n            trace = _a.sent();\n            return [2\n            /*return*/\n            , trace];\n        }\n      });\n    });\n  };\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n\n\n  Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sign',\n              params: [address, message]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n\n\n  Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_signTypedData',\n              params: [address, typedData]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n\n\n  Web3Wrapper.prototype.getBlockNumberAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex, blockNumber;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_blockNumber',\n              params: []\n            })];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return [2\n            /*return*/\n            , blockNumber];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = false;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n              blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n\n            return [2\n            /*return*/\n            , blockWithoutTransactionDataIfExists];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n\n\n  Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = blockParam;\n\n            if (_.isNumber(blockParam)) {\n              encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = true;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithTransactionDataWithHexValues = _a.sent();\n            blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return [2\n            /*return*/\n            , blockWithoutTransactionData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n\n\n  Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            return [4\n            /*yield*/\n            , this.getBlockIfExistsAsync(blockParam)];\n\n          case 1:\n            blockIfExists = _a.sent();\n\n            if (blockIfExists === undefined) {\n              throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n            }\n\n            return [2\n            /*return*/\n            , blockIfExists.timestamp];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n\n\n  Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_accounts',\n              params: []\n            })];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddresses = _.map(addresses, function (address) {\n              return address.toLowerCase();\n            });\n            return [2\n            /*return*/\n            , normalizedAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n\n\n  Web3Wrapper.prototype.takeSnapshotAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshotId, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Number;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_snapshot',\n              params: []\n            })];\n\n          case 1:\n            snapshotId = _a.apply(void 0, [_b.sent()]);\n            return [2\n            /*return*/\n            , snapshotId];\n        }\n      });\n    });\n  };\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n\n\n  Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var didRevert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_revert',\n              params: [snapshotId]\n            })];\n\n          case 1:\n            didRevert = _a.sent();\n            return [2\n            /*return*/\n            , didRevert];\n        }\n      });\n    });\n  };\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n\n\n  Web3Wrapper.prototype.mineBlockAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_mine',\n              params: []\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n\n\n  Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              })];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              })];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n\n\n  Web3Wrapper.prototype.getLogsAsync = function (filter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            }\n\n            fromBlock = filter.fromBlock;\n\n            if (_.isNumber(fromBlock)) {\n              fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n\n            toBlock = filter.toBlock;\n\n            if (_.isNumber(toBlock)) {\n              toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n\n            serializedFilter = __assign({}, filter, {\n              fromBlock: fromBlock,\n              toBlock: toBlock\n            });\n            payload = {\n              method: 'eth_getLogs',\n              params: [serializedFilter]\n            };\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync(payload)];\n\n          case 1:\n            rawLogs = _a.sent();\n            formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return [2\n            /*return*/\n            , formattedLogs];\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n\n\n  Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, gasHex, gas;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_estimateGas',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            gasHex = _a.sent();\n            gas = utils_2.utils.convertHexToNumber(gasHex);\n            return [2\n            /*return*/\n            , gas];\n        }\n      });\n    });\n  };\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n\n\n  Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, callDataHex, rawCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_call',\n              params: [callDataHex, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            rawCallResult = _a.sent();\n            return [2\n            /*return*/\n            , rawCallResult];\n        }\n      });\n    });\n  };\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n\n\n  Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, txHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sendTransaction',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            txHash = _a.sent();\n            return [2\n            /*return*/\n            , txHash];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n\n            if (timeoutMs !== undefined) {\n              assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n\n            return [4\n            /*yield*/\n            , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n          case 1:\n            transactionReceipt = _a.sent();\n\n            if (transactionReceipt !== undefined) {\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                logs: logsWithDecodedArgs\n              });\n              return [2\n              /*return*/\n              , transactionReceiptWithDecodedLogArgs];\n            }\n\n            wasTimeoutExceeded = false;\n\n            if (timeoutMs) {\n              setTimeout(function () {\n                return wasTimeoutExceeded = true;\n              }, timeoutMs);\n            }\n\n            txReceiptPromise = new Promise(function (resolve, reject) {\n              var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        if (wasTimeoutExceeded) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return [2\n                          /*return*/\n                          , reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                        }\n\n                        return [4\n                        /*yield*/\n                        , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n                      case 1:\n                        transactionReceipt = _a.sent();\n\n                        if (transactionReceipt !== undefined) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                          transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                            logs: logsWithDecodedArgs\n                          });\n                          resolve(transactionReceiptWithDecodedLogArgs);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              }, pollingIntervalMs, function (err) {\n                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                reject(err);\n              });\n            });\n            return [4\n            /*yield*/\n            , txReceiptPromise];\n\n          case 2:\n            txReceipt = _a.sent();\n            return [2\n            /*return*/\n            , txReceipt];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var receipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n\n          case 1:\n            receipt = _a.sent();\n\n            if (receipt.status !== 1) {\n              throw new Error(\"Transaction failed: \" + txHash);\n            }\n\n            return [2\n            /*return*/\n            , receipt];\n        }\n      });\n    });\n  };\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n\n\n  Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_setHead',\n              params: [utils_2.utils.numberToHex(blockNumber)]\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n\n\n  Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sendAsync, payloadWithDefaults, response, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sendAsync = this._provider.sendAsync.bind(this._provider);\n            payloadWithDefaults = __assign({\n              id: this._jsonRpcRequestId++,\n              params: [],\n              jsonrpc: '2.0'\n            }, payload);\n            return [4\n            /*yield*/\n            , utils_1.promisify(sendAsync)(payloadWithDefaults)];\n\n          case 1:\n            response = _a.sent();\n\n            if (response.error) {\n              throw new Error(response.error.message);\n            }\n\n            result = response.result;\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n\n\n  Web3Wrapper.prototype.getNodeTypeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Geth];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Ganache];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\n\n\nexports.Web3Wrapper = Web3Wrapper;","map":{"version":3,"mappings":"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","names":["BASE_TEN","uniqueVersionIds","geth","ganache","supportedProvider","callAndTxnDefaults","abiDecoder","utils_1","_supportedProvider","_provider","standardizeOrThrow","_callAndTxnDefaults","_jsonRpcRequestId","Web3Wrapper","address","isAddress","amount","decimals","assert_1","isValidBaseUnitAmount","isNumber","aUnit","pow","unit","div","isBigNumber","baseUnitAmount","times","hasDecimals","decimalPlaces","Error","toString","ethAmount","ETH_DECIMALS","balanceWei","toBaseUnitAmount","blockParam","_","isString","doesBelongToStringEnum","ethereum_types_1","_assertBlockParam","err","isHexString","status","utils_2","convertHexToNumber","undefined","provider","senderAddress","isETHAddressHex","getAvailableAddressesAsync","addresses","_a","normalizedAddress","toLowerCase","includes","sendRawPayloadAsync","method","nodeVersion","networkIdStr","networkId","parseInt","txHash","params","transactionReceiptRpc","blockNumber","_normalizeTxReceiptStatus","transactionReceipt","marshaller_1","unmarshalTransactionReceipt","transactionRpc","transaction","unmarshalTransaction","owner","defaultBlock","marshalledDefaultBlock","marshalBlockParam","encodedOwner","marshalAddress","balanceInWei","getContractCodeAsync","code","isCodeEmpty","test","encodedAddress","traceParams","trace","message","signData","typedData","doesConformToSchema","json_schemas_1","eip712TypedDataSchema","blockNumberHex","convertHexToNumberOrNull","_assertBlockParamOrString","encodedBlockParam","isHexStrict","shouldIncludeTransactionData","blockWithoutTransactionDataWithHexValuesOrNull","blockWithoutTransactionDataIfExists","unmarshalIntoBlockWithoutTransactionData","numberToHex","blockWithTransactionDataWithHexValues","blockWithoutTransactionData","unmarshalIntoBlockWithTransactionData","getBlockIfExistsAsync","blockIfExists","JSON","stringify","timestamp","normalizedAddresses","map","snapshotId","_b","didRevert","timeDelta","getNodeVersionAsync","version","filter","blockHash","fromBlock","toBlock","serializedFilter","payload","rawLogs","formattedLogs","unmarshalLog","bind","txData","txDataSchema","addressSchema","numberSchema","jsNumber","txDataHex","marshalTxData","gasHex","gas","callData","callDataSchema","callDataHex","marshalCallData","rawCallResult","pollingIntervalMs","timeoutMs","getTransactionReceiptIfExistsAsync","logsWithDecodedArgs","logs","tryToDecodeLogOrNoop","transactionReceiptWithDecodedLogArgs","wasTimeoutExceeded","setTimeout","txReceiptPromise","Promise","resolve","reject","intervalId","setAsyncExcludingInterval","clearAsyncExcludingInterval","types_1","TransactionMiningTimeout","txReceipt","awaitTransactionMinedAsync","receipt","sendAsync","payloadWithDefaults","id","jsonrpc","response","error","result","Geth","Ganache","exports"],"sources":["../../src/web3_wrapper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}